{
  "language": "Solidity",
  "sources": {
    "contracts/abstract/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Helper utility that enables calling multiple local methods in a single call.\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol)\n/// License-Identifier: GPL-2.0-or-later\nabstract contract Multicall {\n    function multicall(bytes[] calldata data) public payable returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        \n        for (uint256 i; i < data.length;) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n\n            // cannot realistically overflow on human timescales\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../abstract/Multicall.sol\";\nimport \"../../abstract/TridentERC721.sol\";\nimport \"../../interfaces/IMasterDeployer.sol\";\nimport \"../../interfaces/IBentoBoxMinimal.sol\";\nimport \"../../interfaces/ITridentRouter.sol\";\nimport \"../../interfaces/IConcentratedLiquidityPoolManager.sol\";\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport \"../../interfaces/IPositionManager.sol\";\nimport \"../../libraries/FullMath.sol\";\nimport \"../../libraries/TickMath.sol\";\nimport \"../../libraries/DyDxMath.sol\";\n\n/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.\ncontract ConcentratedLiquidityPoolManager is IConcentratedLiquidityPoolManagerStruct, IPositionManager, TridentERC721, Multicall {\n    event IncreaseLiquidity(address indexed pool, address indexed owner, uint256 indexed positionId, uint128 liquidity);\n    event DecreaseLiquidity(address indexed pool, address indexed owner, uint256 indexed positionId, uint128 liquidity);\n\n    address internal cachedMsgSender = address(1);\n    address internal cachedPool = address(1);\n\n    address internal immutable wETH;\n    IBentoBoxMinimal public immutable bento;\n    IMasterDeployer public immutable masterDeployer;\n\n    mapping(uint256 => Position) public positions;\n\n    constructor(address _masterDeployer, address _wETH) {\n        masterDeployer = IMasterDeployer(_masterDeployer);\n        IBentoBoxMinimal _bento = IBentoBoxMinimal(IMasterDeployer(_masterDeployer).bento());\n        _bento.registerProtocol();\n        bento = _bento;\n        wETH = _wETH;\n        mint(address(this));\n    }\n\n    function mint(\n        IConcentratedLiquidityPool pool,\n        int24 lowerOld,\n        int24 lower,\n        int24 upperOld,\n        int24 upper,\n        uint128 amount0Desired,\n        uint128 amount1Desired,\n        bool native,\n        uint256 minLiquidity,\n        uint256 positionId\n    ) external payable returns (uint256 _positionId) {\n        require(masterDeployer.pools(address(pool)), \"INVALID_POOL\");\n\n        cachedMsgSender = msg.sender;\n        cachedPool = address(pool);\n\n        uint128 liquidityMinted = uint128(\n            pool.mint(\n                IConcentratedLiquidityPoolStruct.MintParams({\n                    lowerOld: lowerOld,\n                    lower: lower,\n                    upperOld: upperOld,\n                    upper: upper,\n                    amount0Desired: amount0Desired,\n                    amount1Desired: amount1Desired,\n                    native: native\n                })\n            )\n        );\n\n        require(liquidityMinted >= minLiquidity, \"TOO_LITTLE_RECEIVED\");\n\n        (uint256 feeGrowthInside0, uint256 feeGrowthInside1) = pool.rangeFeeGrowth(lower, upper);\n\n        if (positionId == 0) {\n            // We mint a new NFT.\n            _positionId = nftCount.minted;\n            positions[_positionId] = Position({\n                pool: pool,\n                liquidity: liquidityMinted,\n                lower: lower,\n                upper: upper,\n                latestAddition: uint32(block.timestamp),\n                feeGrowthInside0: feeGrowthInside0,\n                feeGrowthInside1: feeGrowthInside1\n            });\n            mint(msg.sender);\n        } else {\n            // We increase liquidity for an existing NFT.\n            _positionId = positionId;\n            Position storage position = positions[_positionId];\n            require(address(position.pool) == address(pool), \"POOL_MIS_MATCH\");\n            require(position.lower == lower && position.upper == upper, \"RANGE_MIS_MATCH\");\n            require(ownerOf(positionId) == msg.sender, \"NOT_ID_OWNER\");\n            // Fees should be claimed first.\n            position.feeGrowthInside0 = feeGrowthInside0;\n            position.feeGrowthInside1 = feeGrowthInside1;\n            position.liquidity += liquidityMinted;\n            // Incentives should be claimed first.\n            position.latestAddition = uint32(block.timestamp);\n        }\n\n        emit IncreaseLiquidity(address(pool), msg.sender, _positionId, liquidityMinted);\n\n        cachedMsgSender = address(1);\n        cachedPool = address(1);\n    }\n\n    function mintCallback(\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1,\n        bool native\n    ) external override {\n        require(msg.sender == cachedPool, \"UNAUTHORIZED_CALLBACK\");\n        if (native) {\n            _depositFromUserToBentoBox(token0, cachedMsgSender, msg.sender, amount0);\n            _depositFromUserToBentoBox(token1, cachedMsgSender, msg.sender, amount1);\n        } else {\n            bento.transfer(token0, cachedMsgSender, msg.sender, amount0);\n            bento.transfer(token1, cachedMsgSender, msg.sender, amount1);\n        }\n        cachedMsgSender = address(1);\n        cachedPool = address(1);\n    }\n\n    function burn(\n        uint256 tokenId,\n        uint128 amount,\n        address recipient,\n        bool unwrapBento,\n        uint256 minimumOut0,\n        uint256 minimumOut1\n    ) external returns (uint256 token0Amount, uint256 token1Amount) {\n        require(msg.sender == ownerOf(tokenId), \"NOT_ID_OWNER\");\n\n        Position memory position = positions[tokenId];\n\n        (uint256 token0Fees, uint256 token1Fees, uint256 feeGrowthInside0, uint256 feeGrowthInside1) = positionFees(tokenId);\n\n        if (amount < position.liquidity) {\n            (token0Amount, token1Amount, , ) = position.pool.burn(position.lower, position.upper, amount);\n\n            positions[tokenId].feeGrowthInside0 = feeGrowthInside0;\n            positions[tokenId].feeGrowthInside1 = feeGrowthInside1;\n            positions[tokenId].liquidity -= amount;\n        } else {\n            amount = position.liquidity;\n            (token0Amount, token1Amount, , ) = position.pool.burn(position.lower, position.upper, amount);\n            burn(tokenId);\n            delete positions[tokenId];\n        }\n\n        require(token0Amount >= minimumOut0 && token1Amount >= minimumOut1, \"TOO_LITTLE_RECEIVED\");\n\n        unchecked {\n            token0Amount += token0Fees;\n            token1Amount += token1Fees;\n        }\n\n        _transferBoth(position.pool, recipient, token0Amount, token1Amount, unwrapBento);\n\n        emit DecreaseLiquidity(address(position.pool), msg.sender, tokenId, amount);\n    }\n\n    function collect(\n        uint256 tokenId,\n        address recipient,\n        bool unwrapBento\n    ) public returns (uint256 token0amount, uint256 token1amount) {\n        require(msg.sender == ownerOf(tokenId), \"NOT_ID_OWNER\");\n        Position storage position = positions[tokenId];\n\n        (, , , , , , address token0, address token1) = position.pool.getImmutables();\n\n        (token0amount, token1amount, position.feeGrowthInside0, position.feeGrowthInside1) = positionFees(tokenId);\n\n        uint256 balance0 = bento.balanceOf(token0, address(this));\n        uint256 balance1 = bento.balanceOf(token1, address(this));\n\n        if (balance0 < token0amount || balance1 < token1amount) {\n            (uint256 amount0fees, uint256 amount1fees) = position.pool.collect(position.lower, position.upper);\n\n            uint256 newBalance0 = amount0fees + balance0;\n            uint256 newBalance1 = amount1fees + balance1;\n\n            // Rounding errors due to frequent claiming of other users in the same position may cost us some wei units.\n            if (token0amount > newBalance0) token0amount = newBalance0;\n            if (token1amount > newBalance1) token1amount = newBalance1;\n        }\n\n        _transferOut(token0, recipient, token0amount, unwrapBento);\n        _transferOut(token1, recipient, token1amount, unwrapBento);\n    }\n\n    /// @notice Returns the claimable fees and the fee growth accumulators of a given position.\n    function positionFees(uint256 tokenId)\n        public\n        view\n        returns (\n            uint256 token0amount,\n            uint256 token1amount,\n            uint256 feeGrowthInside0,\n            uint256 feeGrowthInside1\n        )\n    {\n        Position memory position = positions[tokenId];\n\n        (feeGrowthInside0, feeGrowthInside1) = position.pool.rangeFeeGrowth(position.lower, position.upper);\n\n        token0amount = FullMath.mulDiv(\n            feeGrowthInside0 - position.feeGrowthInside0,\n            position.liquidity,\n            0x100000000000000000000000000000000\n        );\n\n        token1amount = FullMath.mulDiv(\n            feeGrowthInside1 - position.feeGrowthInside1,\n            position.liquidity,\n            0x100000000000000000000000000000000\n        );\n    }\n\n    function _transferBoth(\n        IConcentratedLiquidityPool pool,\n        address to,\n        uint256 token0Amount,\n        uint256 token1Amount,\n        bool unwrapBento\n    ) internal {\n        (, , , , , , address token0, address token1) = pool.getImmutables();\n        _transferOut(token0, to, token0Amount, unwrapBento);\n        _transferOut(token1, to, token1Amount, unwrapBento);\n    }\n\n    function _transferOut(\n        address token,\n        address to,\n        uint256 shares,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, address(this), to, 0, shares);\n        } else {\n            bento.transfer(token, address(this), to, shares);\n        }\n    }\n\n    function _depositFromUserToBentoBox(\n        address token,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        if (token == wETH && address(this).balance > 0) {\n            // 'amount' is in BentoBox share units.\n            uint256 ethAmount = bento.toAmount(token, amount, true);\n            if (address(this).balance >= ethAmount) {\n                bento.deposit{value: ethAmount}(address(0), sender, recipient, 0, amount);\n                return;\n            }\n        }\n        bento.deposit(token, sender, recipient, 0, amount);\n    }\n}\n"
    },
    "contracts/abstract/TridentERC721.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nabstract contract TridentERC721 is ERC721 {\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n\n    bytes32 public constant PERMIT_ALL_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 nonce,uint256 deadline)\");\n\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n\n    uint256 internal immutable DOMAIN_SEPARATOR_CHAIN_ID;\n\n    struct NFTCounter {\n        uint128 minted;\n        uint128 burned;\n    }\n\n    NFTCounter public nftCount;\n\n    mapping(uint256 => uint256) public nonces;\n\n    mapping(address => uint256) public noncesForAll;\n\n    constructor() ERC721(\"TridentNFT\", \"tNFT\") {\n        DOMAIN_SEPARATOR_CHAIN_ID = block.chainid;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator();\n    }\n\n    function _calculateDomainSeparator() internal view returns (bytes32 domainSeperator) {\n        domainSeperator = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(\"TridentNFT\")),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32 domainSeperator) {\n        domainSeperator = block.chainid == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator();\n    }\n\n    function mint(address recipient) internal {\n        _mint(recipient, nftCount.minted++);\n    }\n\n    function burn(uint256 tokenId) internal {\n        nftCount.burned++;\n        _burn(tokenId);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return nftCount.minted - nftCount.burned;\n    }\n\n    function permit(\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        address owner = ownerOf(tokenId);\n        /// @dev This is reasonably safe from overflow - incrementing `nonces` beyond\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonces[tokenId]++, deadline))\n                )\n            );\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0), \"INVALID_PERMIT_SIGNATURE\");\n            require(recoveredAddress == owner || isApprovedForAll(owner, recoveredAddress), \"INVALID_SIGNER\");\n        }\n        _approve(spender, tokenId);\n    }\n\n    function permitAll(\n        address owner,\n        address operator,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n        /// @dev This is reasonably safe from overflow - incrementing `nonces` beyond\n        // 'type(uint256).max' is exceedingly unlikely compared to optimization benefits.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_ALL_TYPEHASH, owner, operator, noncesForAll[owner]++, deadline))\n                )\n            );\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(\n                (recoveredAddress != address(0) && recoveredAddress == owner) || isApprovedForAll(owner, recoveredAddress),\n                \"INVALID_PERMIT_SIGNATURE\"\n            );\n        }\n        _setApprovalForAll(owner, operator, true);\n    }\n}\n"
    },
    "contracts/interfaces/IMasterDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident pool deployer interface.\ninterface IMasterDeployer {\n    function barFee() external view returns (uint256);\n\n    function barFeeTo() external view returns (address);\n\n    function bento() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function pools(address pool) external view returns (bool);\n\n    function deployPool(address factory, bytes calldata deployData) external returns (address);\n}\n"
    },
    "contracts/interfaces/IBentoBoxMinimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../libraries/RebaseLibrary.sol\";\n\n/// @notice Minimal BentoBox vault interface.\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\ninterface IBentoBoxMinimal {\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    /// @dev Reads the Rebase `totals`from storage for a given token\n    function totals(address token) external view returns (Rebase memory total);\n\n    /// @dev Approves users' BentoBox assets to a \"master\" contract.\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/ITridentRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident pool router interface.\ninterface ITridentRouter {\n    struct Path {\n        address pool;\n        bytes data;\n    }\n\n    struct ExactInputSingleParams {\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        address pool;\n        address tokenIn;\n        bytes data;\n    }\n\n    struct ExactInputParams {\n        address tokenIn;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        Path[] path;\n    }\n\n    struct TokenInput {\n        address token;\n        bool native;\n        uint256 amount;\n    }\n\n    struct InitialPath {\n        address tokenIn;\n        address pool;\n        bool native;\n        uint256 amount;\n        bytes data;\n    }\n\n    struct PercentagePath {\n        address tokenIn;\n        address pool;\n        uint64 balancePercentage; // Multiplied by 10^6. 100% = 100_000_000\n        bytes data;\n    }\n\n    struct Output {\n        address token;\n        address to;\n        bool unwrapBento;\n        uint256 minAmount;\n    }\n\n    struct ComplexPathParams {\n        InitialPath[] initialPath;\n        PercentagePath[] percentagePath;\n        Output[] output;\n    }\n}\n"
    },
    "contracts/interfaces/IConcentratedLiquidityPoolManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./IConcentratedLiquidityPool.sol\";\nimport \"./ITridentNFT.sol\";\n\n/// @notice Trident concentrated liquidity pool manager contract Structs.\ninterface IConcentratedLiquidityPoolManagerStruct {\n    struct Position {\n        IConcentratedLiquidityPool pool;\n        uint128 liquidity;\n        int24 lower;\n        int24 upper;\n        uint32 latestAddition;\n        uint256 feeGrowthInside0; /// @dev Per unit of liquidity.\n        uint256 feeGrowthInside1;\n    }\n}\n\n/// @notice Trident concentrated liquidity manager contract interface.\ninterface IConcentratedLiquidityPoolManager is IConcentratedLiquidityPoolManagerStruct, ITridentNFT {\n    function positions(uint256) external view returns (Position memory);\n\n    function bento() external view returns (IBentoBoxMinimal);\n}\n"
    },
    "contracts/interfaces/IConcentratedLiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./IBentoBoxMinimal.sol\";\nimport \"./IMasterDeployer.sol\";\nimport \"../libraries/Ticks.sol\";\n\n/// @notice Trident concentrated liquidity pool contract Structs.\ninterface IConcentratedLiquidityPoolStruct {\n    struct Tick {\n        int24 previousTick;\n        int24 nextTick;\n        uint128 liquidity;\n        uint256 feeGrowthOutside0; // Per unit of liquidity.\n        uint256 feeGrowthOutside1;\n        uint160 secondsGrowthOutside;\n    }\n    struct Position {\n        uint128 liquidity;\n        uint256 feeGrowthInside0Last;\n        uint256 feeGrowthInside1Last;\n    }\n\n    struct MintParams {\n        int24 lowerOld;\n        int24 lower;\n        int24 upperOld;\n        int24 upper;\n        uint128 amount0Desired;\n        uint128 amount1Desired;\n        bool native;\n    }\n\n    struct SwapCache {\n        uint256 feeAmount;\n        uint256 totalFeeAmount;\n        uint256 protocolFee;\n        uint256 feeGrowthGlobalA;\n        uint256 feeGrowthGlobalB;\n        uint256 currentPrice;\n        uint256 currentLiquidity;\n        uint256 input;\n        int24 nextTickToCross;\n    }\n}\n\n/// @notice Trident Concentrated Liquidity Pool interface.\ninterface IConcentratedLiquidityPool is IConcentratedLiquidityPoolStruct {\n    function ticks(int24 _tick) external view returns (Tick memory);\n\n    function positions(\n        address owner,\n        int24 lower,\n        int24 upper\n    ) external view returns (Position memory);\n\n    function feeGrowthGlobal0() external view returns (uint256);\n\n    function feeGrowthGlobal1() external view returns (uint256);\n\n    function rangeFeeGrowth(int24 lowerTick, int24 upperTick) external view returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1);\n\n    function setPrice(uint160 price) external;\n\n    function collect(int24 lower, int24 upper) external returns (uint256 amount0fees, uint256 amount1fees);\n\n    function mint(MintParams memory data) external returns (uint256 liquidityMinted);\n\n    function burn(\n        int24 lower,\n        int24 upper,\n        uint128 amount\n    )\n        external\n        returns (\n            uint256 token0Amount,\n            uint256 token1Amount,\n            uint256 token0Fees,\n            uint256 token1Fees\n        );\n\n    function getImmutables()\n        external\n        view\n        returns (\n            uint128 _MAX_TICK_LIQUIDITY,\n            uint24 _tickSpacing,\n            uint24 _swapFee,\n            address _barFeeTo,\n            IBentoBoxMinimal _bento,\n            IMasterDeployer _masterDeployer,\n            address _token0,\n            address _token1\n        );\n\n    function getPriceAndNearestTicks() external view returns (uint160 _price, int24 _nearestTick);\n\n    function getTokenProtocolFees() external view returns (uint128 _token0ProtocolFee, uint128 _token1ProtocolFee);\n\n    function getReserves() external view returns (uint128 _reserve0, uint128 _reserve1);\n\n    function getAssets() external view returns (address[] memory tokens);\n\n    function getSecondsGrowthAndLastObservation() external view returns (uint160 _secondGrowthGlobal, uint32 _lastObservation);\n}\n"
    },
    "contracts/interfaces/IPositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident concentrated Liquidity pool mint callback receiver.\ninterface IPositionManager {\n    function mintCallback(\n        address token0,\n        address token1,\n        uint256 amount0,\n        uint256 amount1,\n        bool native\n    ) external;\n}\n"
    },
    "contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.\n/// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/FullMath.sol.\n/// @dev Handles \"phantom overflow\", i.e., allows multiplication and division where an intermediate value overflows 256 bits.\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision - throws if result overflows an uint256 or denominator == 0.\n    /// @param a The multiplicand.\n    /// @param b The multiplier.\n    /// @param denominator The divisor.\n    /// @return result The 256-bit result.\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b.\n            // Compute the product mod 2**256 and mod 2**256 - 1,\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product.\n            uint256 prod1; // Most significant 256 bits of the product.\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n            // Make sure the result is less than 2**256 -\n            // also prevents denominator == 0.\n            require(denominator > prod1);\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n            // Make division exact by subtracting the remainder from [prod1 prod0] -\n            // compute remainder using mulmod.\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number.\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            // Factor powers of two out of denominator -\n            // compute largest power of two divisor of denominator\n            // (always >= 1).\n            uint256 twos = uint256(-int256(denominator)) & denominator;\n            // Divide denominator by power of two.\n            assembly {\n                denominator := div(denominator, twos)\n            }\n            // Divide [prod1 prod0] by the factors of two.\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos -\n            // if twos is zero, then it becomes one.\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            // Invert denominator mod 2**256 -\n            // now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // for four bits. That is, denominator * inv = 1 mod 2**4.\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // Inverse mod 2**8.\n            inv *= 2 - denominator * inv; // Inverse mod 2**16.\n            inv *= 2 - denominator * inv; // Inverse mod 2**32.\n            inv *= 2 - denominator * inv; // Inverse mod 2**64.\n            inv *= 2 - denominator * inv; // Inverse mod 2**128.\n            inv *= 2 - denominator * inv; // Inverse mod 2**256.\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision - throws if result overflows an uint256 or denominator == 0.\n    /// @param a The multiplicand.\n    /// @param b The multiplier.\n    /// @param denominator The divisor.\n    /// @return result The 256-bit result.\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        unchecked {\n            if (mulmod(a, b, denominator) != 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Math library for computing sqrt price for ticks of size 1.0001, i.e., sqrt(1.0001^tick) as fixed point Q64.96 numbers - supports\n/// prices between 2**-128 and 2**128 - 1.\n/// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/TickMath.sol.\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128.\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128 - 1.\n    int24 internal constant MAX_TICK = -MIN_TICK;\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick - equivalent to getSqrtRatioAtTick(MIN_TICK).\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick - equivalent to getSqrtRatioAtTick(MAX_TICK).\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    error TickOutOfBounds();\n    error PriceOutOfBounds();\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96.\n    /// @dev Throws if |tick| > max tick.\n    /// @param tick The input tick for the above formula.\n    /// @return sqrtPriceX96 Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick.\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        if (absTick > uint256(uint24(MAX_TICK))) revert TickOutOfBounds();\n        unchecked {\n            uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n            // This divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.\n            // We round up in the division so getTickAtSqrtRatio of the output price is always consistent.\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    function validatePrice(uint160 price) internal pure {\n        if (price < MIN_SQRT_RATIO || price >= MAX_SQRT_RATIO) revert PriceOutOfBounds();\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio.\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96.\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // Second inequality must be < because the price can never reach the price at the max tick.\n        if (sqrtPriceX96 < MIN_SQRT_RATIO || sqrtPriceX96 >= MAX_SQRT_RATIO) revert PriceOutOfBounds();\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n        unchecked {\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number.\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"
    },
    "contracts/libraries/DyDxMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./FullMath.sol\";\nimport \"./UnsafeMath.sol\";\nimport \"./SafeCast.sol\";\n\n/// @notice Math library that facilitates ranged liquidity calculations.\nlibrary DyDxMath {\n    function getDy(\n        uint256 liquidity,\n        uint256 priceLower,\n        uint256 priceUpper,\n        bool roundUp\n    ) internal pure returns (uint256 dy) {\n        unchecked {\n            if (roundUp) {\n                dy = FullMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, 0x1000000000000000000000000);\n            } else {\n                dy = FullMath.mulDiv(liquidity, priceUpper - priceLower, 0x1000000000000000000000000);\n            }\n        }\n    }\n\n    function getDx(\n        uint256 liquidity,\n        uint256 priceLower,\n        uint256 priceUpper,\n        bool roundUp\n    ) internal pure returns (uint256 dx) {\n        unchecked {\n            if (roundUp) {\n                dx = UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(liquidity << 96, priceUpper - priceLower, priceUpper), priceLower);\n            } else {\n                dx = FullMath.mulDiv(liquidity << 96, priceUpper - priceLower, priceUpper) / priceLower;\n            }\n        }\n    }\n\n    function getLiquidityForAmounts(\n        uint256 priceLower,\n        uint256 priceUpper,\n        uint256 currentPrice,\n        uint256 dy,\n        uint256 dx\n    ) public pure returns (uint256 liquidity) {\n        unchecked {\n            if (priceUpper <= currentPrice) {\n                liquidity = FullMath.mulDiv(dy, 0x1000000000000000000000000, priceUpper - priceLower);\n            } else if (currentPrice <= priceLower) {\n                liquidity = FullMath.mulDiv(\n                    dx,\n                    FullMath.mulDiv(priceLower, priceUpper, 0x1000000000000000000000000),\n                    priceUpper - priceLower\n                );\n            } else {\n                uint256 liquidity0 = FullMath.mulDiv(\n                    dx,\n                    FullMath.mulDiv(priceUpper, currentPrice, 0x1000000000000000000000000),\n                    priceUpper - currentPrice\n                );\n                uint256 liquidity1 = FullMath.mulDiv(dy, 0x1000000000000000000000000, currentPrice - priceLower);\n                liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n            }\n        }\n    }\n\n    function getAmountsForLiquidity(\n        uint256 priceLower,\n        uint256 priceUpper,\n        uint256 currentPrice,\n        uint256 liquidityAmount,\n        bool roundUp\n    ) internal pure returns (uint128 token0amount, uint128 token1amount) {\n        if (priceUpper <= currentPrice) {\n            // Only supply `token1` (`token1` is Y).\n            token1amount = SafeCast.toUint128(DyDxMath.getDy(liquidityAmount, priceLower, priceUpper, roundUp));\n        } else if (currentPrice <= priceLower) {\n            // Only supply `token0` (`token0` is X).\n            token0amount = SafeCast.toUint128(DyDxMath.getDx(liquidityAmount, priceLower, priceUpper, roundUp));\n        } else {\n            // Supply both tokens.\n            token0amount = SafeCast.toUint128(DyDxMath.getDx(liquidityAmount, currentPrice, priceUpper, roundUp));\n            token1amount = SafeCast.toUint128(DyDxMath.getDy(liquidityAmount, priceLower, currentPrice, roundUp));\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/libraries/RebaseLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8;\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library\nlibrary RebaseLibrary {\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(Rebase memory total, uint256 elastic) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = (elastic * total.base) / total.elastic;\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(Rebase memory total, uint256 base) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = (base * total.elastic) / total.base;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ITridentNFT.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident NFT interface.\ninterface ITridentNFT {\n    function ownerOf(uint256) external view returns (address);\n}\n"
    },
    "contracts/libraries/Ticks.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./TickMath.sol\";\nimport \"../interfaces/IConcentratedLiquidityPool.sol\";\n\n/// @notice Tick management library for ranged liquidity.\nlibrary Ticks {\n    function getMaxLiquidity(uint24 _tickSpacing) public pure returns (uint128) {\n        return type(uint128).max / uint128(uint24(TickMath.MAX_TICK) / (2 * uint24(_tickSpacing)));\n    }\n\n    function cross(\n        mapping(int24 => IConcentratedLiquidityPoolStruct.Tick) storage ticks,\n        int24 nextTickToCross,\n        uint160 secondsGrowthGlobal,\n        uint256 currentLiquidity,\n        uint256 feeGrowthGlobalA,\n        uint256 feeGrowthGlobalB,\n        bool zeroForOne,\n        uint24 tickSpacing\n    ) internal returns (uint256, int24) {\n        ticks[nextTickToCross].secondsGrowthOutside = secondsGrowthGlobal - ticks[nextTickToCross].secondsGrowthOutside;\n\n        if (zeroForOne) {\n            // Moving backwards through the linked list.\n            // Liquidity cannot overflow due to the MAX_TICK_LIQUIDITY requirement.\n            unchecked {\n                if ((nextTickToCross / int24(tickSpacing)) % 2 == 0) {\n                    currentLiquidity -= ticks[nextTickToCross].liquidity;\n                } else {\n                    currentLiquidity += ticks[nextTickToCross].liquidity;\n                }\n            }\n            ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobalB - ticks[nextTickToCross].feeGrowthOutside0;\n            ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobalA - ticks[nextTickToCross].feeGrowthOutside1;\n            nextTickToCross = ticks[nextTickToCross].previousTick;\n        } else {\n            // Moving forwards through the linked list.\n            unchecked {\n                if ((nextTickToCross / int24(tickSpacing)) % 2 == 0) {\n                    currentLiquidity += ticks[nextTickToCross].liquidity;\n                } else {\n                    currentLiquidity -= ticks[nextTickToCross].liquidity;\n                }\n            }\n            ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobalB - ticks[nextTickToCross].feeGrowthOutside1;\n            ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobalA - ticks[nextTickToCross].feeGrowthOutside0;\n            nextTickToCross = ticks[nextTickToCross].nextTick;\n        }\n        return (currentLiquidity, nextTickToCross);\n    }\n\n    function insert(\n        mapping(int24 => IConcentratedLiquidityPoolStruct.Tick) storage ticks,\n        uint256 feeGrowthGlobal0,\n        uint256 feeGrowthGlobal1,\n        uint160 secondsGrowthGlobal,\n        int24 lowerOld,\n        int24 lower,\n        int24 upperOld,\n        int24 upper,\n        uint128 amount,\n        int24 nearestTick,\n        uint160 currentPrice\n    ) public returns (int24) {\n        require(lower < upper, \"WRONG_ORDER\");\n        require(TickMath.MIN_TICK <= lower, \"LOWER_RANGE\");\n        require(upper <= TickMath.MAX_TICK, \"UPPER_RANGE\");\n\n        {\n            // Stack overflow.\n            uint128 currentLowerLiquidity = ticks[lower].liquidity;\n            if (currentLowerLiquidity != 0 || lower == TickMath.MIN_TICK) {\n                // We are adding liquidity to an existing tick.\n                ticks[lower].liquidity = currentLowerLiquidity + amount;\n            } else {\n                // We are inserting a new tick.\n                IConcentratedLiquidityPoolStruct.Tick storage old = ticks[lowerOld];\n                int24 oldNextTick = old.nextTick;\n\n                require((old.liquidity != 0 || lowerOld == TickMath.MIN_TICK) && lowerOld < lower && lower < oldNextTick, \"LOWER_ORDER\");\n\n                if (lower <= nearestTick) {\n                    ticks[lower] = IConcentratedLiquidityPoolStruct.Tick(\n                        lowerOld,\n                        oldNextTick,\n                        amount,\n                        feeGrowthGlobal0,\n                        feeGrowthGlobal1,\n                        secondsGrowthGlobal\n                    );\n                } else {\n                    ticks[lower] = IConcentratedLiquidityPoolStruct.Tick(lowerOld, oldNextTick, amount, 0, 0, 0);\n                }\n\n                old.nextTick = lower;\n                ticks[oldNextTick].previousTick = lower;\n            }\n        }\n\n        uint128 currentUpperLiquidity = ticks[upper].liquidity;\n        if (currentUpperLiquidity != 0 || upper == TickMath.MAX_TICK) {\n            // We are adding liquidity to an existing tick.\n            ticks[upper].liquidity = currentUpperLiquidity + amount;\n        } else {\n            // Inserting a new tick.\n            IConcentratedLiquidityPoolStruct.Tick storage old = ticks[upperOld];\n            int24 oldNextTick = old.nextTick;\n\n            require(old.liquidity != 0 && oldNextTick > upper && upperOld < upper, \"UPPER_ORDER\");\n\n            if (upper <= nearestTick) {\n                ticks[upper] = IConcentratedLiquidityPoolStruct.Tick(\n                    upperOld,\n                    oldNextTick,\n                    amount,\n                    feeGrowthGlobal0,\n                    feeGrowthGlobal1,\n                    secondsGrowthGlobal\n                );\n            } else {\n                ticks[upper] = IConcentratedLiquidityPoolStruct.Tick(upperOld, oldNextTick, amount, 0, 0, 0);\n            }\n            old.nextTick = upper;\n            ticks[oldNextTick].previousTick = upper;\n        }\n\n        int24 tickAtPrice = TickMath.getTickAtSqrtRatio(currentPrice);\n\n        if (nearestTick < upper && upper <= tickAtPrice) {\n            nearestTick = upper;\n        } else if (nearestTick < lower && lower <= tickAtPrice) {\n            nearestTick = lower;\n        }\n\n        return nearestTick;\n    }\n\n    function remove(\n        mapping(int24 => IConcentratedLiquidityPoolStruct.Tick) storage ticks,\n        int24 lower,\n        int24 upper,\n        uint128 amount,\n        int24 nearestTick\n    ) public returns (int24) {\n        IConcentratedLiquidityPoolStruct.Tick storage current = ticks[lower];\n\n        if (lower != TickMath.MIN_TICK && current.liquidity == amount) {\n            // Delete lower tick.\n            IConcentratedLiquidityPoolStruct.Tick storage previous = ticks[current.previousTick];\n            IConcentratedLiquidityPoolStruct.Tick storage next = ticks[current.nextTick];\n\n            previous.nextTick = current.nextTick;\n            next.previousTick = current.previousTick;\n\n            if (nearestTick == lower) nearestTick = current.previousTick;\n\n            delete ticks[lower];\n        } else {\n            unchecked {\n                current.liquidity -= amount;\n            }\n        }\n\n        current = ticks[upper];\n\n        if (upper != TickMath.MAX_TICK && current.liquidity == amount) {\n            // Delete upper tick.\n            IConcentratedLiquidityPoolStruct.Tick storage previous = ticks[current.previousTick];\n            IConcentratedLiquidityPoolStruct.Tick storage next = ticks[current.nextTick];\n\n            previous.nextTick = current.nextTick;\n            next.previousTick = current.previousTick;\n\n            if (nearestTick == upper) nearestTick = current.previousTick;\n\n            delete ticks[upper];\n        } else {\n            unchecked {\n                current.liquidity -= amount;\n            }\n        }\n\n        return nearestTick;\n    }\n}\n"
    },
    "contracts/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.5.0;\n\n/// @notice Math library that contains methods that perform common math functions but do not do any overflow or underflow checks.\n/// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/UnsafeMath.sol.\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y).\n    /// @dev Division by 0 has unspecified behavior, and must be checked externally.\n    /// @param x The dividend.\n    /// @param y The divisor.\n    /// @return z The quotient, ceil(x / y).\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n"
    },
    "contracts/libraries/SafeCast.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity >=0.8.0;\n\nlibrary SafeCast {\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    function toUint128(uint256 y) internal pure returns (uint128 z) {\n        require((z = uint128(y)) == y);\n    }\n}\n"
    },
    "contracts/pool/concentrated/ConcentratedLiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IBentoBoxMinimal.sol\";\nimport \"../../interfaces/IMasterDeployer.sol\";\nimport \"../../interfaces/ITridentCallee.sol\";\nimport \"../../interfaces/ITridentRouter.sol\";\nimport \"../../interfaces/IPositionManager.sol\";\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport \"../../libraries/FullMath.sol\";\nimport \"../../libraries/TickMath.sol\";\nimport \"../../libraries/UnsafeMath.sol\";\nimport \"../../libraries/DyDxMath.sol\";\nimport \"../../libraries/SwapLib.sol\";\nimport \"../../libraries/Ticks.sol\";\n\n/// @notice Trident Concentrated liquidity pool implementation.\n/// @dev Amounts are considered to be in Bentobox shared\ncontract ConcentratedLiquidityPool is IConcentratedLiquidityPoolStruct {\n    using Ticks for mapping(int24 => Tick);\n\n    event Mint(address indexed owner, uint256 amount0, uint256 amount1);\n    event Burn(address indexed owner, uint256 amount0, uint256 amount1);\n    event Collect(address indexed sender, uint256 amount0, uint256 amount1);\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    uint24 internal constant MAX_FEE = 100000; /// @dev Maximum `swapFee` is 10%.\n    /// @dev Reference: tickSpacing of 100 -> 2% between ticks.\n    uint24 internal immutable tickSpacing;\n    uint24 internal immutable swapFee; /// @dev 1000 corresponds to 0.1% fee. Fee is measured in pips.\n    uint128 internal immutable MAX_TICK_LIQUIDITY;\n\n    address internal immutable barFeeTo;\n    IBentoBoxMinimal internal immutable bento;\n    IMasterDeployer internal immutable masterDeployer;\n\n    address internal immutable token0;\n    address internal immutable token1;\n\n    uint128 public liquidity;\n\n    uint160 internal secondsGrowthGlobal; /// @dev Multiplied by 2^128.\n    uint32 internal lastObservation;\n\n    uint256 public feeGrowthGlobal0; /// @dev All fee growth counters are multiplied by 2^128.\n    uint256 public feeGrowthGlobal1;\n\n    uint256 public barFee;\n\n    uint128 internal token0ProtocolFee;\n    uint128 internal token1ProtocolFee;\n\n    uint128 internal reserve0; /// @dev `bento` share balance tracker.\n    uint128 internal reserve1;\n\n    uint160 internal price; /// @dev Sqrt of price aka. √(y/x), multiplied by 2^96.\n    int24 internal nearestTick; /// @dev Tick that is just below the current price.\n\n    uint256 internal unlocked;\n\n    mapping(int24 => Tick) public ticks;\n    mapping(address => mapping(int24 => mapping(int24 => Position))) public positions;\n\n    /// @dev Error list to optimize around pool requirements.\n    error Locked();\n    error ZeroAddress();\n    error InvalidToken();\n    error InvalidSwapFee();\n    error LiquidityOverflow();\n    error Token0Missing();\n    error Token1Missing();\n    error InvalidTick();\n    error LowerEven();\n    error UpperOdd();\n    error MaxTickLiquidity();\n    error Overflow();\n\n    modifier lock() {\n        if (unlocked == 2) revert Locked();\n        unlocked = 2;\n        _;\n        unlocked = 1;\n    }\n\n    /// @dev Only set immutable variables here - state changes made here will not be used.\n    constructor(bytes memory _deployData, IMasterDeployer _masterDeployer) {\n        (address _token0, address _token1, uint24 _swapFee, uint24 _tickSpacing) = abi.decode(\n            _deployData,\n            (address, address, uint24, uint24)\n        );\n\n        if (_token0 == address(0)) revert ZeroAddress();\n        if (_token0 == address(this)) revert InvalidToken();\n        if (_token1 == address(this)) revert InvalidToken();\n        if (_swapFee > MAX_FEE) revert InvalidSwapFee();\n\n        token0 = _token0;\n        token1 = _token1;\n        swapFee = _swapFee;\n        tickSpacing = _tickSpacing;\n        bento = IBentoBoxMinimal(_masterDeployer.bento());\n        barFeeTo = _masterDeployer.barFeeTo();\n        barFee = _masterDeployer.barFee();\n        masterDeployer = _masterDeployer;\n        MAX_TICK_LIQUIDITY = Ticks.getMaxLiquidity(_tickSpacing);\n        ticks[TickMath.MIN_TICK] = Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);\n        ticks[TickMath.MAX_TICK] = Tick(TickMath.MIN_TICK, TickMath.MAX_TICK, uint128(0), 0, 0, 0);\n        nearestTick = TickMath.MIN_TICK;\n        unlocked = 1;\n        lastObservation = uint32(block.timestamp);\n    }\n\n    /// @dev Called only once from the factory.\n    /// @dev Price is not a constructor parameter to allow for predictable address calculation.\n    function setPrice(uint160 _price) external {\n        if (price == 0) {\n            TickMath.validatePrice(_price);\n            price = _price;\n        }\n    }\n\n    /// @dev Mints LP tokens - should be called via the CL pool manager contract.\n    function mint(MintParams memory mintParams) public lock returns (uint256 liquidityMinted) {\n        _ensureTickSpacing(mintParams.lower, mintParams.upper);\n\n        uint256 priceLower = uint256(TickMath.getSqrtRatioAtTick(mintParams.lower));\n        uint256 priceUpper = uint256(TickMath.getSqrtRatioAtTick(mintParams.upper));\n        uint256 currentPrice = uint256(price);\n\n        liquidityMinted = DyDxMath.getLiquidityForAmounts(\n            priceLower,\n            priceUpper,\n            currentPrice,\n            uint256(mintParams.amount1Desired),\n            uint256(mintParams.amount0Desired)\n        );\n\n        // Ensure no overflow happens when we cast from uint256 to int128.\n        if (liquidityMinted > uint128(type(int128).max)) revert Overflow();\n\n        _updateSecondsPerLiquidity(uint256(liquidity));\n\n        unchecked {\n            (uint256 amount0Fees, uint256 amount1Fees) = _updatePosition(\n                msg.sender,\n                mintParams.lower,\n                mintParams.upper,\n                int128(uint128(liquidityMinted))\n            );\n            if (amount0Fees > 0) {\n                _transfer(token0, amount0Fees, msg.sender, false);\n                reserve0 -= uint128(amount0Fees);\n            }\n            if (amount1Fees > 0) {\n                _transfer(token1, amount1Fees, msg.sender, false);\n                reserve1 -= uint128(amount1Fees);\n            }\n\n            if (priceLower <= currentPrice && currentPrice < priceUpper) liquidity += uint128(liquidityMinted);\n        }\n\n        nearestTick = Ticks.insert(\n            ticks,\n            feeGrowthGlobal0,\n            feeGrowthGlobal1,\n            secondsGrowthGlobal,\n            mintParams.lowerOld,\n            mintParams.lower,\n            mintParams.upperOld,\n            mintParams.upper,\n            uint128(liquidityMinted),\n            nearestTick,\n            uint160(currentPrice)\n        );\n\n        (uint128 amount0Actual, uint128 amount1Actual) = DyDxMath.getAmountsForLiquidity(\n            priceLower,\n            priceUpper,\n            currentPrice,\n            liquidityMinted,\n            true\n        );\n\n        IPositionManager(msg.sender).mintCallback(token0, token1, amount0Actual, amount1Actual, mintParams.native);\n\n        if (amount0Actual != 0) {\n            reserve0 += amount0Actual;\n            if (reserve0 > _balance(token0)) revert Token0Missing();\n        }\n\n        if (amount1Actual != 0) {\n            reserve1 += amount1Actual;\n            if (reserve1 > _balance(token1)) revert Token1Missing();\n        }\n\n        emit Mint(msg.sender, amount0Actual, amount1Actual);\n    }\n\n    function burn(\n        int24 lower,\n        int24 upper,\n        uint128 amount\n    )\n        public\n        lock\n        returns (\n            uint256 token0Amount,\n            uint256 token1Amount,\n            uint256 token0Fees,\n            uint256 token1Fees\n        )\n    {\n        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\n        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\n        uint160 currentPrice = price;\n\n        _updateSecondsPerLiquidity(uint256(liquidity));\n\n        unchecked {\n            if (priceLower <= currentPrice && currentPrice < priceUpper) liquidity -= amount;\n        }\n\n        (token0Amount, token1Amount) = DyDxMath.getAmountsForLiquidity(\n            uint256(priceLower),\n            uint256(priceUpper),\n            uint256(currentPrice),\n            uint256(amount),\n            false\n        );\n\n        // Ensure no overflow happens when we cast from uint128 to int128.\n        if (amount > uint128(type(int128).max)) revert Overflow();\n\n        (token0Fees, token1Fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n\n        uint256 amount0;\n        uint256 amount1;\n\n        unchecked {\n            amount0 = token0Amount + token0Fees;\n            amount1 = token1Amount + token1Fees;\n            reserve0 -= uint128(amount0);\n            reserve1 -= uint128(amount1);\n        }\n\n        _transferBothTokens(msg.sender, amount0, amount1);\n\n        nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);\n\n        emit Burn(msg.sender, amount0, amount1);\n    }\n\n    function collect(int24 lower, int24 upper) public lock returns (uint256 amount0fees, uint256 amount1fees) {\n        (amount0fees, amount1fees) = _updatePosition(msg.sender, lower, upper, 0);\n\n        reserve0 -= uint128(amount0fees);\n        reserve1 -= uint128(amount1fees);\n\n        _transferBothTokens(msg.sender, amount0fees, amount1fees);\n\n        emit Collect(msg.sender, amount0fees, amount1fees);\n    }\n\n    function _updateSecondsPerLiquidity(uint256 currentLiquidity) internal {\n        unchecked {\n            uint256 diff = block.timestamp - uint256(lastObservation);\n            if (diff > 0 && currentLiquidity > 0) {\n                lastObservation = uint32(block.timestamp); // Overfyarnlow in 2106. Don't do staking rewards in the year 2106.\n                secondsGrowthGlobal += uint160((diff << 128) / currentLiquidity);\n            }\n        }\n    }\n\n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\n    function swap(bytes memory data) public lock returns (uint256 amountOut) {\n        (bool zeroForOne, address recipient, bool unwrapBento) = abi.decode(data, (bool, address, bool));\n\n        uint256 inAmount = _balance(zeroForOne ? token0 : token1) - (zeroForOne ? reserve0 : reserve1);\n\n        SwapCache memory cache = SwapCache({\n            feeAmount: 0,\n            totalFeeAmount: 0,\n            protocolFee: 0,\n            feeGrowthGlobalA: zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0,\n            feeGrowthGlobalB: zeroForOne ? feeGrowthGlobal0 : feeGrowthGlobal1,\n            currentPrice: uint256(price),\n            currentLiquidity: uint256(liquidity),\n            input: inAmount,\n            nextTickToCross: zeroForOne ? nearestTick : ticks[nearestTick].nextTick\n        });\n\n        _updateSecondsPerLiquidity(cache.currentLiquidity);\n\n        while (cache.input != 0) {\n            uint256 nextTickPrice = uint256(TickMath.getSqrtRatioAtTick(cache.nextTickToCross));\n            uint256 output = 0;\n            bool cross = false;\n\n            if (zeroForOne) {\n                // Trading token 0 (x) for token 1 (y).\n                // Price is decreasing.\n                // Maximum input amount within current tick range: Δx = Δ(1/√𝑃) · L.\n                uint256 maxDx = DyDxMath.getDx(cache.currentLiquidity, nextTickPrice, cache.currentPrice, false);\n\n                if (cache.input <= maxDx) {\n                    // We can swap within the current range.\n                    uint256 liquidityPadded = cache.currentLiquidity << 96;\n                    // Calculate new price after swap: √𝑃[new] =  L · √𝑃 / (L + Δx · √𝑃)\n                    // This is derived from Δ(1/√𝑃) = Δx/L\n                    // where Δ(1/√𝑃) is 1/√𝑃[old] - 1/√𝑃[new] and we solve for √𝑃[new].\n                    // In case of an overflow we can use: √𝑃[new] = L / (L / √𝑃 + Δx).\n                    // This is derived by dividing the original fraction by √𝑃 on both sides.\n                    uint256 newPrice = uint256(\n                        FullMath.mulDivRoundingUp(liquidityPadded, cache.currentPrice, liquidityPadded + cache.currentPrice * cache.input)\n                    );\n\n                    if (!(nextTickPrice <= newPrice && newPrice < cache.currentPrice)) {\n                        // Overflow. We use a modified version of the formula.\n                        newPrice = uint160(UnsafeMath.divRoundingUp(liquidityPadded, liquidityPadded / cache.currentPrice + cache.input));\n                    }\n                    // Based on the price difference calculate the output of th swap: Δy = Δ√P · L.\n                    output = DyDxMath.getDy(cache.currentLiquidity, newPrice, cache.currentPrice, false);\n                    cache.currentPrice = newPrice;\n                    cache.input = 0;\n                } else {\n                    // Execute swap step and cross the tick.\n                    output = DyDxMath.getDy(cache.currentLiquidity, nextTickPrice, cache.currentPrice, false);\n                    cache.currentPrice = nextTickPrice;\n                    cross = true;\n                    cache.input -= maxDx;\n                }\n            } else {\n                // Price is increasing.\n                // Maximum swap amount within the current tick range: Δy = Δ√P · L.\n                uint256 maxDy = DyDxMath.getDy(cache.currentLiquidity, cache.currentPrice, nextTickPrice, false);\n\n                if (cache.input <= maxDy) {\n                    // We can swap within the current range.\n                    // Calculate new price after swap: ΔP = Δy/L.\n                    uint256 newPrice = cache.currentPrice +\n                        FullMath.mulDiv(cache.input, 0x1000000000000000000000000, cache.currentLiquidity);\n                    // Calculate output of swap\n                    // - Δx = Δ(1/√P) · L.\n                    output = DyDxMath.getDx(cache.currentLiquidity, cache.currentPrice, newPrice, false);\n                    cache.currentPrice = newPrice;\n                    cache.input = 0;\n                } else {\n                    // Swap & cross the tick.\n                    output = DyDxMath.getDx(cache.currentLiquidity, cache.currentPrice, nextTickPrice, false);\n                    cache.currentPrice = nextTickPrice;\n                    cross = true;\n                    cache.input -= maxDy;\n                }\n            }\n\n            // cache.feeGrowthGlobalA is the feeGrowthGlobal counter for the output token.\n            // It increases each swap step.\n            (cache.totalFeeAmount, amountOut, cache.protocolFee, cache.feeGrowthGlobalA) = SwapLib.handleFees(\n                output,\n                swapFee,\n                barFee,\n                cache.currentLiquidity,\n                cache.totalFeeAmount,\n                amountOut,\n                cache.protocolFee,\n                cache.feeGrowthGlobalA\n            );\n            if (cross) {\n                (cache.currentLiquidity, cache.nextTickToCross) = Ticks.cross(\n                    ticks,\n                    cache.nextTickToCross,\n                    secondsGrowthGlobal,\n                    cache.currentLiquidity,\n                    cache.feeGrowthGlobalA,\n                    cache.feeGrowthGlobalB,\n                    zeroForOne,\n                    tickSpacing\n                );\n                if (cache.currentLiquidity == 0) {\n                    // We step into a zone that has liquidity - or we reach the end of the linked list.\n                    cache.currentPrice = uint256(TickMath.getSqrtRatioAtTick(cache.nextTickToCross));\n                    (cache.currentLiquidity, cache.nextTickToCross) = Ticks.cross(\n                        ticks,\n                        cache.nextTickToCross,\n                        secondsGrowthGlobal,\n                        cache.currentLiquidity,\n                        cache.feeGrowthGlobalA,\n                        cache.feeGrowthGlobalB,\n                        zeroForOne,\n                        tickSpacing\n                    );\n                }\n            }\n        }\n\n        price = uint160(cache.currentPrice);\n\n        int24 newNearestTick = zeroForOne ? cache.nextTickToCross : ticks[cache.nextTickToCross].previousTick;\n\n        if (nearestTick != newNearestTick) {\n            nearestTick = newNearestTick;\n            liquidity = uint128(cache.currentLiquidity);\n        }\n\n        _updateReserves(zeroForOne, uint128(inAmount), amountOut);\n\n        _updateFees(zeroForOne, cache.feeGrowthGlobalA, uint128(cache.protocolFee));\n\n        if (zeroForOne) {\n            _transfer(token1, amountOut, recipient, unwrapBento);\n            emit Swap(recipient, token0, token1, inAmount, amountOut);\n        } else {\n            _transfer(token0, amountOut, recipient, unwrapBento);\n            emit Swap(recipient, token1, token0, inAmount, amountOut);\n        }\n    }\n\n    /// @dev Updates `barFee` for Trident protocol.\n    function updateBarFee() public {\n        barFee = IMasterDeployer(masterDeployer).barFee();\n    }\n\n    /// @dev Collects fees for Trident protocol.\n    function collectProtocolFee() public lock returns (uint128 amount0, uint128 amount1) {\n        if (token0ProtocolFee > 1) {\n            amount0 = token0ProtocolFee - 1;\n            token0ProtocolFee = 1;\n            reserve0 -= amount0;\n            _transfer(token0, amount0, barFeeTo, false);\n        }\n        if (token1ProtocolFee > 1) {\n            amount1 = token1ProtocolFee - 1;\n            token1ProtocolFee = 1;\n            reserve1 -= amount1;\n            _transfer(token1, amount1, barFeeTo, false);\n        }\n    }\n\n    function _ensureTickSpacing(int24 lower, int24 upper) internal view {\n        if (lower % int24(tickSpacing) != 0) revert InvalidTick();\n        if ((lower / int24(tickSpacing)) % 2 != 0) revert LowerEven();\n        if (upper % int24(tickSpacing) != 0) revert InvalidTick();\n        if ((upper / int24(tickSpacing)) % 2 == 0) revert UpperOdd();\n    }\n\n    function _updateReserves(\n        bool zeroForOne,\n        uint128 inAmount,\n        uint256 amountOut\n    ) internal {\n        if (zeroForOne) {\n            uint256 balance0 = _balance(token0);\n            uint128 newBalance = reserve0 + inAmount;\n            if (uint256(newBalance) > balance0) revert Token0Missing();\n            reserve0 = newBalance;\n            unchecked {\n                reserve1 -= uint128(amountOut);\n            }\n        } else {\n            uint256 balance1 = _balance(token1);\n            uint128 newBalance = reserve1 + inAmount;\n            if (uint256(newBalance) > balance1) revert Token1Missing();\n            reserve1 = newBalance;\n            unchecked {\n                reserve0 -= uint128(amountOut);\n            }\n        }\n    }\n\n    function _updateFees(\n        bool zeroForOne,\n        uint256 feeGrowthGlobal,\n        uint128 protocolFee\n    ) internal {\n        if (zeroForOne) {\n            feeGrowthGlobal1 = feeGrowthGlobal;\n            token1ProtocolFee += protocolFee;\n        } else {\n            feeGrowthGlobal0 = feeGrowthGlobal;\n            token0ProtocolFee += protocolFee;\n        }\n    }\n\n    function _updatePosition(\n        address owner,\n        int24 lower,\n        int24 upper,\n        int128 amount\n    ) internal returns (uint256 amount0Fees, uint256 amount1Fees) {\n        Position storage position = positions[owner][lower][upper];\n\n        (uint256 rangeFeeGrowth0, uint256 rangeFeeGrowth1) = rangeFeeGrowth(lower, upper);\n\n        amount0Fees = FullMath.mulDiv(\n            rangeFeeGrowth0 - position.feeGrowthInside0Last,\n            position.liquidity,\n            0x100000000000000000000000000000000\n        );\n\n        amount1Fees = FullMath.mulDiv(\n            rangeFeeGrowth1 - position.feeGrowthInside1Last,\n            position.liquidity,\n            0x100000000000000000000000000000000\n        );\n\n        if (amount < 0) {\n            position.liquidity -= uint128(-amount);\n        }\n\n        if (amount > 0) {\n            position.liquidity += uint128(amount);\n            // Prevents a global liquidity overflow in even if all ticks are initialised.\n            if (position.liquidity > MAX_TICK_LIQUIDITY) revert LiquidityOverflow();\n        }\n\n        position.feeGrowthInside0Last = rangeFeeGrowth0;\n        position.feeGrowthInside1Last = rangeFeeGrowth1;\n    }\n\n    function _balance(address token) internal view returns (uint256 balance) {\n        balance = bento.balanceOf(token, address(this));\n    }\n\n    function _transfer(\n        address token,\n        uint256 shares,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, address(this), to, 0, shares);\n        } else {\n            bento.transfer(token, address(this), to, shares);\n        }\n    }\n\n    function _transferBothTokens(\n        address to,\n        uint256 shares0,\n        uint256 shares1\n    ) internal {\n        bento.transfer(token0, address(this), to, shares0);\n        bento.transfer(token1, address(this), to, shares1);\n    }\n\n    /// @dev Generic formula for fee growth inside a range: (globalGrowth - growthBelow - growthAbove)\n    /// - available counters: global, outside u, outside v.\n\n    ///                  u         ▼         v\n    /// ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - feeGrowthOutside(u) - feeGrowthOutside(v))\n\n    ///             ▼    u                   v\n    /// ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - (global - feeGrowthOutside(u)) - feeGrowthOutside(v))\n\n    ///                  u                   v    ▼\n    /// ----|----|-------|xxxxxxxxxxxxxxxxxxx|--------|--------- (global - feeGrowthOutside(u) - (global - feeGrowthOutside(v)))\n\n    /// @notice Calculates the fee growth inside a range (per unit of liquidity).\n    /// @dev Multiply `rangeFeeGrowth` delta by the provided liquidity to get accrued fees for some period.\n    function rangeFeeGrowth(int24 lowerTick, int24 upperTick) public view returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1) {\n        int24 currentTick = nearestTick;\n\n        Tick storage lower = ticks[lowerTick];\n        Tick storage upper = ticks[upperTick];\n\n        // Calculate fee growth below & above.\n        uint256 _feeGrowthGlobal0 = feeGrowthGlobal0;\n        uint256 _feeGrowthGlobal1 = feeGrowthGlobal1;\n        uint256 feeGrowthBelow0;\n        uint256 feeGrowthBelow1;\n        uint256 feeGrowthAbove0;\n        uint256 feeGrowthAbove1;\n\n        if (lowerTick <= currentTick) {\n            feeGrowthBelow0 = lower.feeGrowthOutside0;\n            feeGrowthBelow1 = lower.feeGrowthOutside1;\n        } else {\n            feeGrowthBelow0 = _feeGrowthGlobal0 - lower.feeGrowthOutside0;\n            feeGrowthBelow1 = _feeGrowthGlobal1 - lower.feeGrowthOutside1;\n        }\n\n        if (currentTick < upperTick) {\n            feeGrowthAbove0 = upper.feeGrowthOutside0;\n            feeGrowthAbove1 = upper.feeGrowthOutside1;\n        } else {\n            feeGrowthAbove0 = _feeGrowthGlobal0 - upper.feeGrowthOutside0;\n            feeGrowthAbove1 = _feeGrowthGlobal1 - upper.feeGrowthOutside1;\n        }\n\n        feeGrowthInside0 = _feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;\n        feeGrowthInside1 = _feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;\n    }\n\n    function getAssets() public view returns (address[] memory assets) {\n        assets = new address[](2);\n        assets[0] = token0;\n        assets[1] = token1;\n    }\n\n    function getImmutables()\n        public\n        view\n        returns (\n            uint128 _MAX_TICK_LIQUIDITY,\n            uint24 _tickSpacing,\n            uint24 _swapFee,\n            address _barFeeTo,\n            IBentoBoxMinimal _bento,\n            IMasterDeployer _masterDeployer,\n            address _token0,\n            address _token1\n        )\n    {\n        _MAX_TICK_LIQUIDITY = MAX_TICK_LIQUIDITY;\n        _tickSpacing = tickSpacing;\n        _swapFee = swapFee; // 1000 corresponds to 0.1% fee.\n        _barFeeTo = barFeeTo;\n        _bento = bento;\n        _masterDeployer = masterDeployer;\n        _token0 = token0;\n        _token1 = token1;\n    }\n\n    function getPriceAndNearestTicks() public view returns (uint160 _price, int24 _nearestTick) {\n        _price = price;\n        _nearestTick = nearestTick;\n    }\n\n    function getTokenProtocolFees() public view returns (uint128 _token0ProtocolFee, uint128 _token1ProtocolFee) {\n        _token0ProtocolFee = token0ProtocolFee;\n        _token1ProtocolFee = token1ProtocolFee;\n    }\n\n    function getReserves() public view returns (uint128 _reserve0, uint128 _reserve1) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n    }\n\n    function getSecondsGrowthAndLastObservation() public view returns (uint160 _secondsGrowthGlobal, uint32 _lastObservation) {\n        _secondsGrowthGlobal = secondsGrowthGlobal;\n        _lastObservation = lastObservation;\n    }\n}\n"
    },
    "contracts/interfaces/ITridentCallee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident pool callback interface.\ninterface ITridentCallee {\n    function tridentSwapCallback(bytes calldata data) external;\n\n    function tridentMintCallback(bytes calldata data) external;\n}\n"
    },
    "contracts/libraries/SwapLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./FullMath.sol\";\n\n/// @notice Math library that facilitates fee handling for Trident Concentrated Liquidity Pools.\nlibrary SwapLib {\n    function handleFees(\n        uint256 output,\n        uint24 swapFee,\n        uint256 barFee,\n        uint256 currentLiquidity,\n        uint256 totalFeeAmount,\n        uint256 amountOut,\n        uint256 protocolFee,\n        uint256 feeGrowthGlobal\n    )\n        internal\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 feeAmount = FullMath.mulDivRoundingUp(output, swapFee, 1e6);\n\n        totalFeeAmount += feeAmount;\n\n        amountOut += output - feeAmount;\n\n        // Calculate `protocolFee` and convert pips to bips.\n        uint256 feeDelta = FullMath.mulDivRoundingUp(feeAmount, barFee, 1e4);\n\n        protocolFee += feeDelta;\n\n        // Updating `feeAmount` based on the protocolFee.\n        feeAmount -= feeDelta;\n\n        feeGrowthGlobal += FullMath.mulDiv(feeAmount, 0x100000000000000000000000000000000, currentLiquidity);\n\n        return (totalFeeAmount, amountOut, protocolFee, feeGrowthGlobal);\n    }\n}\n"
    },
    "contracts/pool/concentrated/ConcentratedLiquidityPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./ConcentratedLiquidityPool.sol\";\nimport \"../../abstract/PoolDeployer.sol\";\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\n\n/// @notice Contract for deploying Trident exchange Concentrated Liquidity Pool with configurations.\n/// @author Mudit Gupta.\ncontract ConcentratedLiquidityPoolFactory is PoolDeployer {\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n\n    error WrongTokenOrder();\n\n    function deployPool(bytes memory _deployData) external returns (address pool) {\n        (address tokenA, address tokenB, uint24 swapFee, uint160 price, uint24 tickSpacing) = abi.decode(\n            _deployData,\n            (address, address, uint24, uint160, uint24)\n        );\n\n        // Revert instead of switching tokens and inverting price.\n        if (tokenA > tokenB) revert WrongTokenOrder();\n\n        // Strips any extra data.\n        // Don't include price in _deployData to enable predictable address calculation.\n        _deployData = abi.encode(tokenA, tokenB, swapFee, tickSpacing);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        // Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.\n        bytes32 salt = keccak256(_deployData);\n        pool = address(new ConcentratedLiquidityPool{salt: salt}(_deployData, IMasterDeployer(masterDeployer)));\n        _registerPool(pool, tokens, salt);\n\n        IConcentratedLiquidityPool(pool).setPrice(price);\n    }\n}\n"
    },
    "contracts/abstract/PoolDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later-only\n\npragma solidity >=0.8.0;\n\n/// @dev Custom Errors\nerror UnauthorisedDeployer();\nerror ZeroAddress();\nerror InvalidTokenOrder();\n\n/// @notice Trident pool deployer for whitelisted template factories.\n/// @author Mudit Gupta.\nabstract contract PoolDeployer {\n    address public immutable masterDeployer;\n\n    mapping(address => mapping(address => address[])) public pools;\n    mapping(bytes32 => address) public configAddress;\n\n    modifier onlyMaster() {\n        if (msg.sender != masterDeployer) revert UnauthorisedDeployer();\n        _;\n    }\n\n    constructor(address _masterDeployer) {\n        if (_masterDeployer == address(0)) revert ZeroAddress();\n        masterDeployer = _masterDeployer;\n    }\n\n    function _registerPool(\n        address pool,\n        address[] memory tokens,\n        bytes32 salt\n    ) internal onlyMaster {\n        // Store the address of the deployed contract.\n        configAddress[salt] = pool;\n        // Attacker used underflow, it was not very effective. poolimon!\n        // null token array would cause deployment to fail via out of bounds memory axis/gas limit.\n        unchecked {\n            for (uint256 i; i < tokens.length - 1; ++i) {\n                if (tokens[i] >= tokens[i + 1]) revert InvalidTokenOrder();\n                for (uint256 j = i + 1; j < tokens.length; ++j) {\n                    pools[tokens[i]][tokens[j]].push(pool);\n                    pools[tokens[j]][tokens[i]].push(pool);\n                }\n            }\n        }\n    }\n\n    function poolsCount(address token0, address token1) external view returns (uint256 count) {\n        count = pools[token0][token1].length;\n    }\n\n    function getPools(\n        address token0,\n        address token1,\n        uint256 startIndex,\n        uint256 count\n    ) external view returns (address[] memory pairPools) {\n        pairPools = new address[](count);\n        for (uint256 i = 0; i < count; i++) {\n            pairPools[i] = pools[token0][token1][startIndex + i];\n        }\n    }\n}\n"
    },
    "contracts/pool/concentrated/ConcentratedLiquidityPoolStaker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../libraries/Ticks.sol\";\nimport \"../../interfaces/IBentoBoxMinimal.sol\";\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport { IConcentratedLiquidityPoolManager as IPoolManager } from \"../../interfaces/IConcentratedLiquidityPoolManager.sol\";\n\n/// @notice Trident Concentrated Liquidity Pool periphery contract that combines non-fungible position management and staking.\ncontract ConcentratedLiquidityPoolStaker {\n    event AddIncentive(IConcentratedLiquidityPool indexed pool, uint256 indexed incentiveId, address indexed rewardToken);\n    event Subscribe(uint256 indexed positionId, uint256 indexed incentiveId);\n    event ClaimReward(uint256 indexed positionId, uint256 indexed incentiveId, address indexed recipient, uint96 amount);\n    event ReclaimIncentive(IConcentratedLiquidityPool indexed pool, uint256 indexed incentiveId, uint256 amount);\n\n    struct Incentive {\n        address owner;\n        address token;\n        uint32 startTime;\n        uint32 endTime;\n        uint32 expiry;\n        uint160 secondsClaimed; // x128.\n        uint96 rewardsUnclaimed;\n    }\n\n    struct Stake {\n        uint160 secondsGrowthInsideLast; // x128.\n        uint32 timestamp;\n    }\n\n    IBentoBoxMinimal public immutable bento;\n    IPoolManager public poolManager;\n\n    mapping(IConcentratedLiquidityPool => uint256) public incentiveCount;\n    mapping(IConcentratedLiquidityPool => mapping(uint256 => Incentive)) public incentives;\n    /// @dev When subscribing to an incentive we take a snapshot of the position secondsGrowth accumulator.\n    /// @dev positionId to incentiveId to position's secondsGrowth snapshot mapping.\n    mapping(uint256 => mapping(uint256 => Stake)) public stakes;\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n        IBentoBoxMinimal _bento = IBentoBoxMinimal(_poolManager.bento());\n        _bento.registerProtocol();\n        bento = _bento;\n    }\n\n    function addIncentive(IConcentratedLiquidityPool pool, Incentive memory incentive) public {\n        uint32 current = uint32(block.timestamp);\n        require(current <= incentive.startTime, \"ALREADY_STARTED\");\n        require(incentive.startTime < incentive.endTime, \"START_PAST_END\");\n        require(incentive.endTime + 90 days < incentive.expiry, \"END_PAST_BUFFER\");\n        require(incentive.rewardsUnclaimed != 0, \"NO_REWARDS\");\n        incentive.secondsClaimed = 0;\n        incentives[pool][incentiveCount[pool]++] = incentive;\n        _transfer(incentive.token, msg.sender, address(this), incentive.rewardsUnclaimed, false);\n        emit AddIncentive(pool, incentiveCount[pool], incentive.token);\n    }\n\n    /// @dev Withdraws any unclaimed incentive rewards.\n    function reclaimIncentive(\n        IConcentratedLiquidityPool pool,\n        uint256 incentiveId,\n        address receiver,\n        uint96 amount,\n        bool unwrapBento\n    ) public {\n        Incentive storage incentive = incentives[pool][incentiveId];\n        require(incentive.owner == msg.sender, \"NOT_OWNER\");\n        require(incentive.expiry < block.timestamp, \"EXPIRED\");\n        require(incentive.rewardsUnclaimed >= amount, \"ALREADY_CLAIMED\");\n        incentive.rewardsUnclaimed -= uint96(amount);\n        _transfer(incentive.token, address(this), receiver, amount, unwrapBento);\n        emit ReclaimIncentive(pool, incentiveId, amount);\n    }\n\n    /// @dev Subscribes a non-fungible position token to an incentive.\n    function subscribe(uint256 positionId, uint256[] calldata incentiveId) external {\n        require(poolManager.ownerOf(positionId) == msg.sender, \"NOT_OWNER\");\n        IPoolManager.Position memory position = poolManager.positions(positionId);\n        IConcentratedLiquidityPool pool = position.pool;\n        require(position.liquidity != 0, \"INACTIVE\");\n        Stake memory stakeData = Stake(uint160(rangeSecondsInside(pool, position.lower, position.upper)), uint32(block.timestamp));\n        for (uint256 i; i < incentiveId.length; i++) {\n            Incentive memory incentive = incentives[pool][incentiveId[i]];\n            Stake storage stake = stakes[positionId][incentiveId[i]];\n            require(stake.secondsGrowthInsideLast == 0, \"SUBSCRIBED\");\n            require(block.timestamp >= incentive.startTime && block.timestamp < incentive.endTime, \"INACTIVE_INCENTIVE\");\n            stakes[positionId][incentiveId[i]] = stakeData;\n            emit Subscribe(positionId, incentiveId[i]);\n        }\n    }\n\n    function claimRewards(\n        uint256 positionId,\n        uint256[] memory incentiveIds,\n        address recipient,\n        bool unwrapBento\n    ) public {\n        require(poolManager.ownerOf(positionId) == msg.sender, \"NOT_OWNER\");\n\n        IPoolManager.Position memory position = poolManager.positions(positionId);\n        IConcentratedLiquidityPool pool = position.pool;\n\n        uint256 currentSecondsGrowth = rangeSecondsInside(pool, position.lower, position.upper);\n\n        for (uint256 i = 0; i < incentiveIds.length; i++) {\n            Incentive storage incentive = incentives[pool][incentiveIds[i]];\n            Stake storage stake = stakes[positionId][incentiveIds[i]];\n\n            // After liquidity is increased on an NFT the owner needs to resubscribe to the incentive.\n            require(stake.timestamp >= position.latestAddition, \"MUST_RESUBSCRIBE\");\n\n            uint256 rewards;\n            uint256 secondsInside;\n\n            {\n                uint256 secondsGrowth = currentSecondsGrowth - stake.secondsGrowthInsideLast;\n                uint256 maxTime = block.timestamp < incentive.endTime ? incentive.endTime : block.timestamp;\n                uint256 secondsUnclaimed = ((maxTime - incentive.startTime) << 128) - incentive.secondsClaimed;\n                secondsInside = secondsGrowth * position.liquidity; // secondsGrowth is multiplied by 2**128\n                rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed; // 2**128 cancels out\n            }\n\n            stake.secondsGrowthInsideLast = uint160(currentSecondsGrowth);\n            incentive.secondsClaimed += uint160(secondsInside);\n            incentive.rewardsUnclaimed -= uint96(rewards);\n\n            _transfer(incentive.token, address(this), recipient, rewards, unwrapBento);\n\n            emit ClaimReward(positionId, incentiveIds[i], recipient, uint96(rewards));\n        }\n    }\n\n    function getReward(uint256 positionId, uint256 incentiveId) public view returns (uint256 rewards, uint256 secondsInside) {\n        IPoolManager.Position memory position = poolManager.positions(positionId);\n        IConcentratedLiquidityPool pool = position.pool;\n        Incentive memory incentive = incentives[pool][positionId];\n        Stake memory stake = stakes[positionId][incentiveId];\n        if (stake.timestamp > 0) {\n            uint256 secondsGrowth = rangeSecondsInside(pool, position.lower, position.upper) - stake.secondsGrowthInsideLast;\n            secondsInside = secondsGrowth * position.liquidity;\n            uint256 maxTime = block.timestamp < incentive.endTime ? incentive.endTime : block.timestamp;\n            uint256 secondsUnclaimed = ((maxTime - incentive.startTime) << 128) - incentive.secondsClaimed;\n            rewards = (incentive.rewardsUnclaimed * secondsInside) / secondsUnclaimed;\n        }\n    }\n\n    /// @dev Calculates the \"seconds per liquidity\" accumulator for a range.\n    function rangeSecondsInside(\n        IConcentratedLiquidityPool pool,\n        int24 lowerTick,\n        int24 upperTick\n    ) public view returns (uint256 secondsInside) {\n        (, int24 currentTick) = pool.getPriceAndNearestTicks();\n\n        IConcentratedLiquidityPool.Tick memory upper = IConcentratedLiquidityPool(pool).ticks(upperTick);\n        IConcentratedLiquidityPool.Tick memory lower = IConcentratedLiquidityPool(pool).ticks(lowerTick);\n\n        (uint256 secondsGrowthGlobal, ) = pool.getSecondsGrowthAndLastObservation();\n        uint256 secondsBelow;\n        uint256 secondsAbove;\n\n        if (lowerTick <= currentTick) {\n            secondsBelow = lower.secondsGrowthOutside;\n        } else {\n            secondsBelow = secondsGrowthGlobal - lower.secondsGrowthOutside;\n        }\n\n        if (currentTick < upperTick) {\n            secondsAbove = upper.secondsGrowthOutside;\n        } else {\n            secondsAbove = secondsGrowthGlobal - upper.secondsGrowthOutside;\n        }\n\n        secondsInside = secondsGrowthGlobal - secondsBelow - secondsAbove;\n    }\n\n    function _transfer(\n        address token,\n        address from,\n        address to,\n        uint256 shares,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, from, to, 0, shares);\n        } else {\n            bento.transfer(token, from, to, shares);\n        }\n    }\n}\n"
    },
    "contracts/pool/solidly/SolidlyPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\nimport {IBentoBoxMinimal} from \"../../interfaces/IBentoBoxMinimal.sol\";\nimport {ISolidlyPoolFactory} from \"../../interfaces/ISolidlyPoolFactory.sol\";\nimport {IMasterDeployer} from \"../../interfaces/IMasterDeployer.sol\";\nimport {IPool} from \"../../interfaces/IPool.sol\";\nimport {TridentMath} from \"../../libraries/TridentMath.sol\";\n\ncontract SolidlyPool is IPool, ERC20, ReentrancyGuard {\n    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;\n\n    address public immutable token0;\n    address public immutable token1;\n\n    IBentoBoxMinimal public immutable bento;\n    IMasterDeployer public immutable masterDeployer;\n\n    uint256 internal immutable decimals0;\n    uint256 internal immutable decimals1;\n\n    uint128 public reserve0;\n    uint128 public reserve1;\n\n    address public feeTo;\n    uint256 public kLast;\n    uint256 public barFee;\n    address public barFeeTo;\n\n    error NotSupported();\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n    event Sync(uint256 reserve0, uint256 reserve1);\n\n    bytes32 public constant override poolIdentifier = \"Trident:SolidlyPool\";\n\n    constructor() ERC20(\"\", \"SLP\", 18) {\n        (bytes memory _deployData, IMasterDeployer _masterDeployer) = ISolidlyPoolFactory(msg.sender).getDeployData();\n\n        (address _token0, address _token1) = abi.decode(_deployData, (address, address));\n\n        (token0, token1) = (_token0, _token1);\n\n        name = string(abi.encodePacked(\"Trident Solidly Pool - \", ERC20(_token0).symbol(), \"/\", ERC20(_token1).symbol()));\n\n        decimals0 = 10**ERC20(_token0).decimals();\n        decimals1 = 10**ERC20(_token1).decimals();\n\n        bento = IBentoBoxMinimal(_masterDeployer.bento());\n        barFee = _masterDeployer.barFee();\n        barFeeTo = _masterDeployer.barFeeTo();\n\n        masterDeployer = _masterDeployer;\n    }\n\n    function getAssets() public view override returns (address[] memory assets) {\n        assets = new address[](2);\n        assets[0] = token0;\n        assets[1] = token1;\n    }\n\n    function getReserves() public view returns (uint256 _reserve0, uint256 _reserve1) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n    }\n\n    function _update(uint256 balance0, uint256 balance1) internal {\n        reserve0 = uint128(balance0);\n        reserve1 = uint128(balance1);\n        emit Sync(reserve0, reserve1);\n    }\n\n    function mint(bytes calldata data) external nonReentrant returns (uint256 liquidity) {\n        address recipient = abi.decode(data, (address));\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n\n        (uint256 _totalSupply, ) = _mintFee(_reserve0, _reserve1);\n\n        if (_totalSupply == 0) {\n            liquidity = _kFromShares(amount0, amount1) - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY);\n        } else {\n            liquidity = _min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);\n        }\n\n        _mint(recipient, liquidity);\n        _update(balance0, balance1);\n        kLast = _fourthRootK(balance0, balance1);\n\n        emit Mint(msg.sender, amount0, amount1, recipient);\n    }\n\n    function burn(bytes calldata data) external override nonReentrant returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        address to = abi.decode(data, (address));\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        (address _token0, address _token1) = (token0, token1);\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 _liquidity = balanceOf[address(this)];\n\n        (uint256 _totalSupply, ) = _mintFee(_reserve0, _reserve1);\n\n        uint256 amount0 = (_liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        uint256 amount1 = (_liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution\n\n        _burn(address(this), _liquidity);\n        _transferShares(_token0, amount0, to, false);\n        _transferShares(_token1, amount1, to, false);\n\n        // This is safe from underflow - amounts are lesser figures derived from balances.\n        unchecked {\n            balance0 -= amount0;\n            balance1 -= amount1;\n        }\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: address(token0), amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: address(token1), amount: amount1});\n\n        _update(balance0, balance1);\n        kLast = _fourthRootK(balance0, balance1);\n\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    function swap(bytes calldata data) external override nonReentrant returns (uint256 amountOut) {\n        (bool zeroForOne, address recipient) = abi.decode(data, (bool, address));\n        (address _token0, address _token1) = (token0, token1);\n        (uint128 _reserve0, uint128 _reserve1) = (reserve0, reserve1);\n\n        require(_reserve0 != 0);\n\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 amountIn;\n\n        if (zeroForOne) {\n            amountIn = balance0 - _reserve0;\n            amountIn -= amountIn / 10000;\n            amountOut = _getAmountOutFromShares(amountIn, _token0, _reserve0, _reserve1);\n            balance1 -= amountOut;\n        } else {\n            amountIn = balance1 - _reserve1;\n            amountIn -= amountIn / 10000;\n            amountOut = _getAmountOutFromShares(amountIn, _token1, _reserve0, _reserve1);\n            balance0 -= amountOut;\n        }\n\n        _transferShares(zeroForOne ? token1 : token0, amountOut, recipient, false);\n        _update(balance0, balance1);\n\n        emit Swap(recipient, zeroForOne ? token0 : token1, zeroForOne ? token1 : token0, amountIn, amountOut);\n    }\n\n    // Mints LP tokens according to the difference between kLast and current reserves.\n    function _mintFee(uint256 _reserve0, uint256 _reserve1) internal returns (uint256 _totalSupply, uint256 computed) {\n        _totalSupply = totalSupply;\n        uint256 _kLast = kLast;\n        if (_kLast != 0) {\n            computed = _fourthRootK(_reserve0, _reserve1);\n            if (computed > _kLast) {\n                // `barFee` % of increase in liquidity.\n                uint256 _barFee = barFee;\n                uint256 numerator = _totalSupply * (computed - _kLast) * _barFee;\n                uint256 denominator = (10000 - _barFee) * computed + _barFee * _kLast;\n                uint256 liquidity = numerator / denominator;\n\n                if (liquidity != 0) {\n                    _mint(barFeeTo, liquidity);\n                    _totalSupply += liquidity;\n                }\n            }\n        }\n    }\n\n    function _fourthRootK(uint256 _reserve0, uint256 _reserve1) internal view returns (uint256) {\n        return TridentMath.sqrt(TridentMath.sqrt(_kFromShares(_reserve0, _reserve1)) * 1e18);\n    }\n\n    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {\n        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        amountIn -= amountIn / 10000; // remove fee from amount received\n        finalAmountOut = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    function getAmountOut(uint256 amountIn, address tokenIn) external view returns (uint256) {\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\n        amountIn -= amountIn / 10000; // remove fee from amount received\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\n    }\n\n    function _getAmountOutFromShares(\n        uint256 amountIn,\n        address tokenIn,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256 amountOut) {\n        // todo optimise use of tokenIn parameter\n        amountOut = _getAmountOut(\n            bento.toAmount(tokenIn, amountIn, false),\n            tokenIn,\n            bento.toAmount(token0, _reserve0, false),\n            bento.toAmount(token1, _reserve1, false)\n        );\n        amountOut = bento.toShare(tokenIn == token0 ? token1 : token0, amountOut, false);\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        address tokenIn,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256) {\n        uint256 xy = _k(_reserve0, _reserve1);\n        _reserve0 = (_reserve0 * 1e18) / decimals0;\n        _reserve1 = (_reserve1 * 1e18) / decimals1;\n        (uint256 reserveA, uint256 reserveB) = tokenIn == token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\n        amountIn = tokenIn == token0 ? (amountIn * 1e18) / decimals0 : (amountIn * 1e18) / decimals1;\n        uint256 y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\n        return (y * (tokenIn == token0 ? decimals1 : decimals0)) / 1e18;\n    }\n\n    function _kFromShares(uint256 x, uint256 y) internal view returns (uint256) {\n        x = bento.toAmount(token0, x, false);\n        y = bento.toAmount(token0, y, false);\n        return _k(x, y);\n    }\n\n    function _k(uint256 x, uint256 y) internal view returns (uint256) {\n        uint256 _x = (x * 1e18) / decimals0;\n        uint256 _y = (y * 1e18) / decimals1;\n        uint256 _a = (_x * _y) / 1e18;\n        uint256 _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\n        return (_a * _b) / 1e18; // x3y+y3x >= k\n    }\n\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return (x0 * ((((y * y) / 1e18) * y) / 1e18)) / 1e18 + (((((x0 * x0) / 1e18) * x0) / 1e18) * y) / 1e18;\n    }\n\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\n        return (3 * x0 * ((y * y) / 1e18)) / 1e18 + ((((x0 * x0) / 1e18) * x0) / 1e18);\n    }\n\n    function _get_y(\n        uint256 x0,\n        uint256 xy,\n        uint256 y\n    ) internal pure returns (uint256) {\n        for (uint256 i = 0; i < 255; i++) {\n            uint256 y_prev = y;\n            uint256 k = _f(x0, y);\n            if (k < xy) {\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\n                y = y + dy;\n            } else {\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\n                y = y - dy;\n            }\n            if (y > y_prev) {\n                if (y - y_prev <= 1) {\n                    return y;\n                }\n            } else {\n                if (y_prev - y <= 1) {\n                    return y;\n                }\n            }\n        }\n        return y;\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _transferShares(\n        address token,\n        uint256 shares,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, address(this), to, 0, shares);\n        } else {\n            bento.transfer(token, address(this), to, shares);\n        }\n    }\n\n    function _balance() internal view returns (uint256 balance0, uint256 balance1) {\n        balance0 = bento.balanceOf(token0, address(this));\n        balance1 = bento.balanceOf(token1, address(this));\n    }\n\n    function getAmountIn(bytes calldata) public pure override returns (uint256) {\n        revert NotSupported();\n    }\n\n    function flashSwap(bytes calldata) public pure override returns (uint256) {\n        revert NotSupported();\n    }\n\n    function burnSingle(bytes calldata) public pure override returns (uint256) {\n        revert NotSupported();\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@rari-capital/solmate/src/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private reentrancyStatus = 1;\n\n    modifier nonReentrant() {\n        require(reentrancyStatus == 1, \"REENTRANCY\");\n\n        reentrancyStatus = 2;\n\n        _;\n\n        reentrancyStatus = 1;\n    }\n}\n"
    },
    "contracts/interfaces/ISolidlyPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./IMasterDeployer.sol\";\n\ninterface ISolidlyPoolFactory {\n    function getDeployData() external view returns (bytes memory, IMasterDeployer);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.5.0;\npragma experimental ABIEncoderV2;\n\n/// @notice Trident pool interface.\ninterface IPool {\n    /// @notice Executes a swap from one token to another.\n    /// @dev The input tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Executes a swap from one token to another with a callback.\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\n\n    /// @notice Mints liquidity tokens.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\n    function mint(bytes calldata data) external returns (uint256 liquidity);\n\n    /// @notice Burns liquidity tokens.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\n\n    /// @notice Burns liquidity tokens for a single output token.\n    /// @dev The input LP tokens must've already been sent to the pool.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return amountOut The amount of output tokens that were sent to the user.\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\n\n    /// @return A unique identifier for the pool type.\n    function poolIdentifier() external pure returns (bytes32);\n\n    /// @return An array of tokens supported by the pool.\n    function getAssets() external view returns (address[] memory);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\n\n    /// @notice Simulates a trade and returns the expected output.\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\n    /// @param data ABI-encoded params that the pool requires.\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\n\n    /// @dev This event must be emitted on all swaps.\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\n\n    /// @dev This struct frames output tokens for burns.\n    struct TokenAmount {\n        address token;\n        uint256 amount;\n    }\n}\n"
    },
    "contracts/libraries/TridentMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident sqrt helper library.\nlibrary TridentMath {\n    /// @dev Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/SolidlyPool.t.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../../lib/ds-test/src/test.sol\";\nimport \"../pool/solidly/SolidlyPool.sol\";\nimport \"../pool/solidly/SolidlyPoolFactory.sol\";\nimport {MasterDeployer} from \"../deployer/MasterDeployer.sol\";\nimport {WETH9} from \"../mocks/WETH9Mock.sol\";\nimport {ERC20Mock} from \"../mocks/ERC20Mock.sol\";\nimport {BentoBoxMock as BentoBox, IERC20 as BentoIERC20} from \"../mocks/BentoBoxMock.sol\";\n\n\ninterface Vm {\n    function prank(address) external;\n}\n\ncontract SolidlyPoolTest is DSTest {\n    WETH9 public weth;\n    BentoBox public bentoBox;\n    MasterDeployer public masterDeployer;\n    SolidlyPoolFactory public factory;\n    ERC20Mock public token0;\n    ERC20Mock public token1;\n    SolidlyPool public pool;\n\n    address public recipient = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266;\n    address public barFeeTo = 0x70997970C51812dc3A010C7d01b50e0d17dc79C8;\n    uint256 public barFee = 1667;\n    uint256 public maxFee = 10000;\n\n    function setUp() public {\n        weth = new WETH9();\n        bentoBox = new BentoBox(BentoIERC20(address(weth)));\n        masterDeployer = new MasterDeployer(barFee, barFeeTo, address(bentoBox));\n        factory = new SolidlyPoolFactory(address(masterDeployer));\n        masterDeployer.addToWhitelist(address(factory));\n        token0 = new ERC20Mock(\"\", \"\", 1e19);\n        token1 = new ERC20Mock(\"\", \"\", 1e19);\n        token0.transfer(address(bentoBox), 1e19);\n        token1.transfer(address(bentoBox), 1e19);\n        bentoBox.deposit(BentoIERC20(address(token0)), address(bentoBox), address(this), 1e19, 0);\n        bentoBox.deposit(BentoIERC20(address(token1)), address(bentoBox), address(this), 1e19, 0);\n        (token0, token1) = address(token0) < address(token1) ? (token0, token1) : (token1, token0);\n        pool = SolidlyPool(masterDeployer.deployPool(address(factory), abi.encode(address(token0), address(token1))));\n        _addLiquidity(1e18, 1e18, address(0));\n    }\n\n    function testInitialisation() public {\n        assertTrue(pool.totalSupply() > 0);\n        assertEq(pool.token0(), address(token0));\n        assertEq(pool.token1(), address(token1));\n    }\n\n    function testAddEqualLiquidity() public {\n        uint256 liquidity = _addLiquidity(1e18, 1e18, address(this));\n        uint256 balance = pool.balanceOf(address(this));\n        assertTrue(balance == liquidity);\n        assertTrue(liquidity > 0);\n    }\n\n    function testBurn() public {\n        (uint256 b0, uint256 b1) = _getBalances(address(this));\n        _burnLiquidity(_addLiquidity(1e18, 1e18, address(this)), address(this), address(this));\n        (uint256 a0, uint256 a1) = _getBalances(address(this));\n        assertEq(b0, a0);\n        assertEq(b1, a1);\n    }\n\n    function testSwap(bool zeroForOne) public {\n        assertEq(_swap(100000000000000, zeroForOne, recipient), 99989999999949);\n        assertEq(_swap(100000000000000, zeroForOne, recipient), 99989999999249);\n    }\n\n    function testMintFee(bool zeroForOne, bool mintFeeBetweenSwaps) public {\n        (uint256 reserve0Before, uint256 reserve1Before) = pool.getReserves();\n        uint256 totalSupplyOld = pool.totalSupply();\n\n        _swap(_swap(1e18, zeroForOne, recipient), !zeroForOne, recipient); // buy and sell\n\n        if (mintFeeBetweenSwaps) _invokeMintFee();\n\n        _swap(_swap(1e18, !zeroForOne, recipient), zeroForOne, recipient); // sell and buy\n\n        (uint256 reserve0After, uint256 reserve1After) = pool.getReserves();\n\n        uint256 change0 = reserve0After - reserve0Before; // Pool profit after swaps.\n        uint256 change1 = reserve1After - reserve1Before; // Pool profit after swaps.\n\n        _invokeMintFee();\n\n        uint256 totalSupply = pool.totalSupply();\n        uint256 barFees = pool.balanceOf(barFeeTo);\n        (uint256 reserve0, uint256 reserve1) = pool.getReserves();\n\n        assertEq(totalSupplyOld + barFees, totalSupply);\n\n        uint256 fees0 = (reserve0 * barFees) / totalSupply;\n        uint256 fees1 = (reserve1 * barFees) / totalSupply;\n\n        uint256 estimated0 = (change0 * barFee) / 10000;\n        uint256 estimated1 = (change1 * barFee) / 10000;\n\n        _assertEqualWithError(fees0, estimated0, 10000);\n        _assertEqualWithError(fees1, estimated1, 10000);\n    }\n\n    function testMintFee(bool zeroForOne) public {\n        (uint256 reserve0Before, uint256 reserve1Before) = pool.getReserves();\n\n        uint256 swapOutput = _swap(1e15, zeroForOne, recipient); // buy and sell\n\n        _claimFees();\n\n        _swap((swapOutput * 10001) / 10000, !zeroForOne, recipient); // sell and buy\n\n        (uint256 reserve0After, uint256 reserve1After) = pool.getReserves();\n\n        _claimFees();\n\n        uint256 profit0 = reserve0After - reserve0Before;\n        uint256 profit1 = reserve1After - reserve1Before;\n\n        (uint256 fees0, uint256 fees1) = _getBalances(barFeeTo);\n\n        assertLt(fees0 * barFee, fees0 * maxFee); // Claiming fees when pool is out of balance is worse for the bar.\n        assertLt(fees1 * barFee, fees1 * maxFee);\n\n        _assertEqualWithError(profit0 * barFee, fees0 * maxFee, 10);\n        _assertEqualWithError(profit1 * barFee, fees1 * maxFee, 10);\n    }\n\n    function _invokeMintFee() internal {\n        pool.burn(abi.encode(recipient));\n    }\n\n    function _swap(\n        uint256 amountIn,\n        bool zeroForOne,\n        address to\n    ) internal returns (uint256 out) {\n        bentoBox.transfer(BentoIERC20(address(zeroForOne ? token0 : token1)), address(this), address(pool), amountIn);\n        (uint256 reserve0Before, uint256 reserve1Before) = pool.getReserves();\n        out = pool.swap(abi.encode(zeroForOne, to));\n        (uint256 reserve0After, uint256 reserve1After) = pool.getReserves();\n        // Check reserves are correctly updated.\n        if (zeroForOne) {\n            assertEq(reserve0Before + amountIn, reserve0After);\n            assertEq(reserve1Before - out, reserve1After);\n        } else {\n            assertEq(reserve0Before - out, reserve0After);\n            assertEq(reserve1Before + amountIn, reserve1After);\n        }\n        // Check balances match reserves.\n        (uint256 balance0, uint256 balance1) = _getPoolBalances();\n        if (to != address(pool)) {\n            assertEq(pool.reserve0(), balance0);\n            assertEq(pool.reserve1(), balance1);\n        } else {\n            assertEq(pool.reserve0() + (zeroForOne ? 0 : out), balance0);\n            assertEq(pool.reserve1() + (zeroForOne ? out : 0), balance1);\n        }\n    }\n\n    function _getPoolBalances() internal view returns (uint256, uint256) {\n        return _getBalances(address(pool));\n    }\n\n    function _getBalances(address acc) internal view returns (uint256 t0, uint256 t1) {\n        t0 = bentoBox.balanceOf(BentoIERC20(address(token0)), address(acc));\n        t1 = bentoBox.balanceOf(BentoIERC20(address(token1)), address(acc));\n    }\n\n    function _addLiquidity(\n        uint256 amount0,\n        uint256 amount1,\n        address to\n    ) internal returns (uint256) {\n        bentoBox.transfer(BentoIERC20(address(token0)), address(this), address(pool), amount0);\n        bentoBox.transfer(BentoIERC20(address(token1)), address(this), address(pool), amount1);\n        return pool.mint(abi.encode(to));\n    }\n\n    function _burnLiquidity(\n        uint256 amount,\n        address from,\n        address to\n    ) internal {\n        pool.burn(abi.encode(address(1))); // Gets rid of any token that are in the pool already and calls mint fee.\n        Vm(HEVM_ADDRESS).prank(from);\n        pool.transfer(address(pool), amount);\n\n        uint256 liquidity = pool.balanceOf(address(pool));\n        uint256 totalSupply = pool.totalSupply();\n        (uint256 reserve0, uint256 reserve1) = pool.getReserves();\n        uint256 expected0 = (reserve0 * liquidity) / totalSupply;\n        uint256 expected1 = (reserve1 * liquidity) / totalSupply;\n        (uint256 toOldBalance0, uint256 toOldBalance1) = _getBalances(to);\n        IPool.TokenAmount[] memory withdrawnAmounts = pool.burn(abi.encode(to));\n        (uint256 toNewBalance0, uint256 toNewBalance1) = _getBalances(to);\n        if (to != address(pool)) {\n            assertEq(toNewBalance0 - toOldBalance0, withdrawnAmounts[0].amount);\n            assertEq(toNewBalance1 - toOldBalance1, withdrawnAmounts[1].amount);\n        }\n        assertEq(expected0, withdrawnAmounts[0].amount);\n        assertEq(expected1, withdrawnAmounts[1].amount);\n    }\n\n    function _assertEqualWithError(\n        uint256 a,\n        uint256 b,\n        uint256 accuracy\n    ) internal {\n        a > b ? assertEq((a * accuracy) / b, accuracy) : assertEq((b * accuracy) / a, accuracy);\n    }\n\n    function _claimFees() internal {\n        _invokeMintFee();\n        uint256 feeBalance = pool.balanceOf(barFeeTo);\n        Vm(HEVM_ADDRESS).prank(barFeeTo);\n        pool.transfer(address(pool), feeBalance);\n        pool.burn(abi.encode(barFeeTo));\n    }\n}\n"
    },
    "lib/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.4.23;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool public failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function fail() internal {\n        failed = true;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Value a\", a);\n            emit log_named_string(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", a);\n            emit log_named_bytes(\"    Actual\", b);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "contracts/pool/solidly/SolidlyPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport {PoolDeployer} from \"../../abstract/PoolDeployer.sol\";\nimport {SolidlyPool} from \"./SolidlyPool.sol\";\nimport {IMasterDeployer} from \"../../interfaces/IMasterDeployer.sol\";\nimport {ISolidlyPoolFactory} from \"../../interfaces/ISolidlyPoolFactory.sol\";\n\n/// @notice Contract for deploying Trident Solidly Pool with configurations.\ncontract SolidlyPoolFactory is ISolidlyPoolFactory, PoolDeployer {\n    bytes32 public constant bytecodeHash = keccak256(type(SolidlyPool).creationCode);\n\n    bytes private cachedDeployData;\n\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n\n    function deployPool(bytes memory _deployData) external returns (address pool) {\n        (address tokenA, address tokenB) = abi.decode(_deployData, (address, address));\n\n        if (tokenA > tokenB) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n\n        // Strips any extra data.\n        _deployData = abi.encode(tokenA, tokenB);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        bytes32 salt = keccak256(_deployData);\n\n        cachedDeployData = _deployData;\n\n        pool = address(new SolidlyPool{salt: salt}());\n\n        cachedDeployData = \"\";\n\n        _registerPool(pool, tokens, salt);\n    }\n\n    // This called in the ConstantProductPool constructor.\n    function getDeployData() external view override returns (bytes memory, IMasterDeployer) {\n        return (cachedDeployData, IMasterDeployer(masterDeployer));\n    }\n\n    function calculatePoolAddress(address token0, address token1) external view returns (address) {\n        bytes32 salt = keccak256(abi.encode(token0, token1));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, bytecodeHash));\n        return address(uint160(uint256(hash)));\n    }\n}\n"
    },
    "contracts/deployer/MasterDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IPoolFactory.sol\";\n\n/// @dev Custom Errors\nerror InvalidBarFee();\nerror ZeroAddress();\nerror NotWhitelisted();\n\n/// @notice Trident pool deployer contract with template factory whitelist.\n/// @author Mudit Gupta.\ncontract MasterDeployer is Ownable {\n    event DeployPool(address indexed factory, address indexed pool, bytes deployData);\n    event AddToWhitelist(address indexed factory);\n    event RemoveFromWhitelist(address indexed factory);\n    event BarFeeUpdated(uint256 indexed barFee);\n\n    uint256 public barFee;\n    address public immutable barFeeTo;\n    address public immutable bento;\n\n    uint256 internal constant MAX_FEE = 10000; // @dev 100%.\n\n    mapping(address => bool) public pools;\n    mapping(address => bool) public whitelistedFactories;\n\n    constructor(\n        uint256 _barFee,\n        address _barFeeTo,\n        address _bento\n    ) {\n        if (_barFee > MAX_FEE) revert InvalidBarFee();\n        if (_barFeeTo == address(0)) revert ZeroAddress();\n        if (_bento == address(0)) revert ZeroAddress();\n\n        barFee = _barFee;\n        barFeeTo = _barFeeTo;\n        bento = _bento;\n    }\n\n    function deployPool(address _factory, bytes calldata _deployData) external returns (address pool) {\n        if (!whitelistedFactories[_factory]) revert NotWhitelisted();\n        pool = IPoolFactory(_factory).deployPool(_deployData);\n        pools[pool] = true;\n        emit DeployPool(_factory, pool, _deployData);\n    }\n\n    function addToWhitelist(address _factory) external onlyOwner {\n        whitelistedFactories[_factory] = true;\n        emit AddToWhitelist(_factory);\n    }\n\n    function removeFromWhitelist(address _factory) external onlyOwner {\n        whitelistedFactories[_factory] = false;\n        emit RemoveFromWhitelist(_factory);\n    }\n\n    function setBarFee(uint256 _barFee) external onlyOwner {\n        if (_barFee > MAX_FEE) revert InvalidBarFee();\n        barFee = _barFee;\n        emit BarFeeUpdated(_barFee);\n    }\n}\n"
    },
    "contracts/mocks/WETH9Mock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >= 0.8.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract WETH9 is ERC20 {\n\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    constructor() ERC20(\"Wrapped Ether\", \"WETH\") {\n        _mint(msg.sender, type(uint128).max);\n    }\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        _burn(msg.sender, wad);\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >= 0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\ncontract ERC20Mock is ERC20Permit {\n    constructor(string memory name, string memory symbol, uint256 supply) ERC20(name, symbol) ERC20Permit(name) {\n        _mint(msg.sender, supply);\n    }\n}\n"
    },
    "contracts/mocks/BentoBoxMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// The BentoBox\n\n//  ▄▄▄▄· ▄▄▄ . ▐ ▄ ▄▄▄▄▄      ▄▄▄▄·       ▐▄• ▄\n//  ▐█ ▀█▪▀▄.▀·█▌▐█•██  ▪     ▐█ ▀█▪▪      █▌█▌▪\n//  ▐█▀▀█▄▐▀▀▪▄▐█▐▐▌ ▐█.▪ ▄█▀▄ ▐█▀▀█▄ ▄█▀▄  ·██·\n//  ██▄▪▐█▐█▄▄▌██▐█▌ ▐█▌·▐█▌.▐▌██▄▪▐█▐█▌.▐▌▪▐█·█▌\n//  ·▀▀▀▀  ▀▀▀ ▀▀ █▪ ▀▀▀  ▀█▄▀▪·▀▀▀▀  ▀█▄▀▪•▀▀ ▀▀\n\n// This contract stores funds, handles their transfers, supports flash loans and strategies.\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to Keno for all his hard work and support\n\n// Version 22-Mar-2021\n\npragma solidity >=0.8.0;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable not-rely-on-time\n// solhint-disable no-inline-assembly\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IERC20.sol@v1.2.0\n// License-Identifier: MIT\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function decimals() external view returns (uint256);\n}\n\n// File contracts/interfaces/IFlashLoan.sol\n// License-Identifier: MIT\n\ninterface IFlashBorrower {\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param token The address of the token that is loaned.\n    /// @param amount of the `token` that is loaned.\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onFlashLoan(\n        address sender,\n        IERC20 token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external;\n}\n\ninterface IBatchFlashBorrower {\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\n    /// @param sender The address of the invoker of this flashloan.\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\n    /// @param amounts A one-to-one map to `tokens` that is loaned.\n    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.\n    /// @param data Additional data that was passed to the flashloan function.\n    function onBatchFlashLoan(\n        address sender,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata fees,\n        bytes calldata data\n    ) external;\n}\n\n// File contracts/interfaces/IWETH.sol\n// License-Identifier: MIT\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n\n// File contracts/interfaces/IStrategy.sol\n// License-Identifier: MIT\n\ninterface IStrategy {\n    /// @notice Send the assets to the Strategy and call skim to invest them.\n    /// @param amount The amount of tokens to invest.\n    function skim(uint256 amount) external;\n\n    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\n    /// @param balance The amount of tokens the caller thinks it has invested.\n    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n\n    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\n    /// @dev The `actualAmount` should be very close to the amount.\n    /// The difference should NOT be used to report a loss. That's what harvest is for.\n    /// @param amount The requested amount the caller wants to withdraw.\n    /// @return actualAmount The real amount that is withdrawn.\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n\n    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.\n    /// @param balance The amount of tokens the caller thinks it has invested.\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\n    function exit(uint256 balance) external returns (int256 amountAdded);\n}\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol@v1.2.0\n// License-Identifier: MIT\n\nlibrary BoringERC20 {\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: Transfer failed\");\n    }\n\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n    /// Reverts on a failed transfer.\n    /// @param token The address of the ERC-20 token.\n    /// @param from Transfer tokens from.\n    /// @param to Transfer tokens to.\n    /// @param amount The token amount.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"BoringERC20: TransferFrom failed\");\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol@v1.2.0\n// License-Identifier: MIT\n\n/// @notice A library for performing overflow-/underflow-safe math,\n/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\nlibrary BoringMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b == 0 || (c = a * b) / b == a, \"BoringMath: Mul Overflow\");\n    }\n\n    function to128(uint256 a) internal pure returns (uint128 c) {\n        require(a <= type(uint128).max, \"BoringMath: uint128 Overflow\");\n        c = uint128(a);\n    }\n\n    function to64(uint256 a) internal pure returns (uint64 c) {\n        require(a <= type(uint64).max, \"BoringMath: uint64 Overflow\");\n        c = uint64(a);\n    }\n\n    function to32(uint256 a) internal pure returns (uint32 c) {\n        require(a <= type(uint32).max, \"BoringMath: uint32 Overflow\");\n        c = uint32(a);\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\nlibrary BoringMath128 {\n    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\nlibrary BoringMath64 {\n    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\nlibrary BoringMath32 {\n    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a + b) >= b, \"BoringMath: Add Overflow\");\n    }\n\n    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n        require((c = a - b) <= a, \"BoringMath: Underflow\");\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol@v1.2.0\n// License-Identifier: MIT\n\nstruct Rebase {\n    uint128 elastic;\n    uint128 base;\n}\n\n/// @notice A rebasing library using overflow-/underflow-safe math.\nlibrary RebaseLibrary {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n    function toBase(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (uint256 base) {\n        if (total.elastic == 0) {\n            base = elastic;\n        } else {\n            base = elastic.mul(total.base) / total.elastic;\n            if (roundUp && base.mul(total.elastic) / total.base < elastic) {\n                base = base.add(1);\n            }\n        }\n    }\n\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n    function toElastic(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (uint256 elastic) {\n        if (total.base == 0) {\n            elastic = base;\n        } else {\n            elastic = base.mul(total.elastic) / total.base;\n            if (roundUp && elastic.mul(total.base) / total.elastic < base) {\n                elastic = elastic.add(1);\n            }\n        }\n    }\n\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\n    /// @return (Rebase) The new total.\n    /// @return base in relationship to `elastic`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 base) {\n        base = toBase(total, elastic, roundUp);\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return (total, base);\n    }\n\n    /// @notice Sub `base` from `total` and update `total.elastic`.\n    /// @return (Rebase) The new total.\n    /// @return elastic in relationship to `base`.\n    function sub(\n        Rebase memory total,\n        uint256 base,\n        bool roundUp\n    ) internal pure returns (Rebase memory, uint256 elastic) {\n        elastic = toElastic(total, base, roundUp);\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return (total, elastic);\n    }\n\n    /// @notice Add `elastic` and `base` to `total`.\n    function add(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.add(elastic.to128());\n        total.base = total.base.add(base.to128());\n        return total;\n    }\n\n    /// @notice Subtract `elastic` and `base` to `total`.\n    function sub(\n        Rebase memory total,\n        uint256 elastic,\n        uint256 base\n    ) internal pure returns (Rebase memory) {\n        total.elastic = total.elastic.sub(elastic.to128());\n        total.base = total.base.sub(base.to128());\n        return total;\n    }\n\n    /// @notice Add `elastic` to `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic = total.elastic.add(elastic.to128());\n    }\n\n    /// @notice Subtract `elastic` from `total` and update storage.\n    /// @return newElastic Returns updated `elastic`.\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n        newElastic = total.elastic = total.elastic.sub(elastic.to128());\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/BoringOwnable.sol@v1.2.0\n// License-Identifier: MIT\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() public {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol@v1.2.0\n// License-Identifier: MIT\n\ninterface IMasterContract {\n    /// @notice Init function that gets called from `BoringFactory.deploy`.\n    /// Also kown as the constructor for cloned contracts.\n    /// Any ETH send to `BoringFactory.deploy` ends up here.\n    /// @param data Can be abi encoded arguments or anything else.\n    function init(bytes calldata data) external payable;\n}\n\n// File @boringcrypto/boring-solidity/contracts/BoringFactory.sol@v1.2.0\n// License-Identifier: MIT\n\ncontract BoringFactory {\n    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\n\n    /// @notice Mapping from clone contracts to their masterContract.\n    mapping(address => address) public masterContractOf;\n\n    /// @notice Deploys a given master Contract as a clone.\n    /// Any ETH transferred with this call is forwarded to the new clone.\n    /// Emits `LogDeploy`.\n    /// @param masterContract The address of the contract to clone.\n    /// @param data Additional abi encoded calldata that is passed to the new clone via `IMasterContract.init`.\n    /// @param useCreate2 Creates the clone by using the CREATE2 opcode, in this case `data` will be used as salt.\n    /// @return cloneAddress Address of the created clone contract.\n    function deploy(\n        address masterContract,\n        bytes calldata data,\n        bool useCreate2\n    ) public payable returns (address cloneAddress) {\n        require(masterContract != address(0), \"BoringFactory: No masterContract\");\n        bytes20 targetBytes = bytes20(masterContract); // Takes the first 20 bytes of the masterContract's address\n\n        if (useCreate2) {\n            // each masterContract has different code already. So clones are distinguished by their data only.\n            bytes32 salt = keccak256(data);\n\n            // Creates clone, more info here: https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\n            assembly {\n                let clone := mload(0x40)\n                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n                mstore(add(clone, 0x14), targetBytes)\n                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n                cloneAddress := create2(0, clone, 0x37, salt)\n            }\n        } else {\n            assembly {\n                let clone := mload(0x40)\n                mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n                mstore(add(clone, 0x14), targetBytes)\n                mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n                cloneAddress := create(0, clone, 0x37)\n            }\n        }\n        masterContractOf[cloneAddress] = masterContract;\n\n        IMasterContract(cloneAddress).init{value: msg.value}(data);\n\n        emit LogDeploy(masterContract, data, cloneAddress);\n    }\n}\n\n// File contracts/MasterContractManager.sol\n// License-Identifier: UNLICENSED\n\ncontract MasterContractManager is BoringOwnable, BoringFactory {\n    event LogWhiteListMasterContract(address indexed masterContract, bool approved);\n    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);\n    event LogRegisterProtocol(address indexed protocol);\n\n    /// @notice masterContract to user to approval state\n    mapping(address => mapping(address => bool)) public masterContractApproved;\n    /// @notice masterContract to whitelisted state for approval without signed message\n    mapping(address => bool) public whitelistedMasterContracts;\n    /// @notice user nonces for masterContract approvals\n    mapping(address => uint256) public nonces;\n\n    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH =\n        keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n    // See https://eips.ethereum.org/EIPS/eip-191\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = \"\\x19\\x01\";\n    bytes32 private constant APPROVAL_SIGNATURE_HASH =\n        keccak256(\"SetMasterContractApproval(string warning,address user,address masterContract,bool approved,uint256 nonce)\");\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\n\n    constructor() public {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n    }\n\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, keccak256(\"BentoBox V1\"), chainId, address(this)));\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    /// @notice Other contracts need to register with this master contract so that users can approve them for the BentoBox.\n    function registerProtocol() public {\n        masterContractOf[msg.sender] = msg.sender;\n        emit LogRegisterProtocol(msg.sender);\n    }\n\n    /// @notice Enables or disables a contract for approval without signed message.\n    function whitelistMasterContract(address masterContract, bool approved) public onlyOwner {\n        // Checks\n        require(masterContract != address(0), \"MasterCMgr: Cannot approve 0\");\n\n        // Effects\n        whitelistedMasterContracts[masterContract] = approved;\n        emit LogWhiteListMasterContract(masterContract, approved);\n    }\n\n    /// @notice Approves or revokes a `masterContract` access to `user` funds.\n    /// @param user The address of the user that approves or revokes access.\n    /// @param masterContract The address who gains or loses access.\n    /// @param approved If True approves access. If False revokes access.\n    /// @param v Part of the signature. (See EIP-191)\n    /// @param r Part of the signature. (See EIP-191)\n    /// @param s Part of the signature. (See EIP-191)\n    // F4 - Check behaviour for all function arguments when wrong or extreme\n    // F4: Don't allow masterContract 0 to be approved. Unknown contracts will have a masterContract of 0.\n    // F4: User can't be 0 for signed approvals because the recoveredAddress will be 0 if ecrecover fails\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        // Checks\n        require(masterContract != address(0), \"MasterCMgr: masterC not set\"); // Important for security\n\n        // If no signature is provided, the fallback is executed\n        if (r == 0 && s == 0 && v == 0) {\n            require(user == msg.sender, \"MasterCMgr: user not sender\");\n            require(masterContractOf[user] == address(0), \"MasterCMgr: user is clone\");\n            require(whitelistedMasterContracts[masterContract], \"MasterCMgr: not whitelisted\");\n        } else {\n            // Important for security - any address without masterContract has address(0) as masterContract\n            // So approving address(0) would approve every address, leading to full loss of funds\n            // Also, ecrecover returns address(0) on failure. So we check this:\n            require(user != address(0), \"MasterCMgr: User cannot be 0\");\n\n            // C10 - Protect signatures against replay, use nonce and chainId (SWC-121)\n            // C10: nonce + chainId are used to prevent replays\n            // C11 - All signatures strictly EIP-712 (SWC-117 SWC-122)\n            // C11: signature is EIP-712 compliant\n            // C12 - abi.encodePacked can't contain variable length user input (SWC-133)\n            // C12: abi.encodePacked has fixed length parameters\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            APPROVAL_SIGNATURE_HASH,\n                            approved\n                                ? keccak256(\"Give FULL access to funds in (and approved to) BentoBox?\")\n                                : keccak256(\"Revoke access to BentoBox?\"),\n                            user,\n                            masterContract,\n                            approved,\n                            nonces[user]++\n                        )\n                    )\n                )\n            );\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress == user, \"MasterCMgr: Invalid Signature\");\n        }\n\n        // Effects\n        masterContractApproved[masterContract][user] = approved;\n        emit LogSetMasterContractApproval(masterContract, user, approved);\n    }\n}\n\n// File @boringcrypto/boring-solidity/contracts/BoringBatchable.sol@v1.2.0\n// License-Identifier: MIT\n\ncontract BaseBoringBatchable {\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param calls An array of inputs for each call.\n    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n    /// @return successes An array indicating the success of a call, mapped one-to-one to `calls`.\n    /// @return results An array with the returned data of each function call, mapped one-to-one to `calls`.\n    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n    // C3: The length of the loop is fully under user control, so can't be exploited\n    // C7: Delegatecall is only used on the same contract, so it's safe\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results) {\n        successes = new bool[](calls.length);\n        results = new bytes[](calls.length);\n        for (uint256 i = 0; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n            require(success || !revertOnFail, _getRevertMsg(result));\n            successes[i] = success;\n            results[i] = result;\n        }\n    }\n}\n\ncontract BoringBatchable is BaseBoringBatchable {\n    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\n    /// Lookup `IERC20.permit`.\n    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\n    //     if part of a batch this could be used to grief once as the second call would not need the permit\n    function permitToken(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        token.permit(from, to, amount, deadline, v, r, s);\n    }\n}\n\n// File contracts/BentoBox.sol\n// License-Identifier: UNLICENSED\n\n/// @title BentoBox\n/// @author BoringCrypto, Keno\n/// @notice The BentoBox is a vault for tokens. The stored tokens can be flash loaned and used in strategies.\n/// Yield from this will go to the token depositors.\n/// Rebasing tokens ARE NOT supported and WILL cause loss of funds.\n/// Any funds transfered directly onto the BentoBox will be lost, use the deposit function instead.\ncontract BentoBoxMock is MasterContractManager, BoringBatchable {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringERC20 for IERC20;\n    using RebaseLibrary for Rebase;\n\n    // ************** //\n    // *** EVENTS *** //\n    // ************** //\n\n    event LogDeposit(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n    event LogWithdraw(IERC20 indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n    event LogTransfer(IERC20 indexed token, address indexed from, address indexed to, uint256 share);\n\n    event LogFlashLoan(address indexed borrower, IERC20 indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);\n\n    event LogStrategyTargetPercentage(IERC20 indexed token, uint256 targetPercentage);\n    event LogStrategyQueued(IERC20 indexed token, IStrategy indexed strategy);\n    event LogStrategySet(IERC20 indexed token, IStrategy indexed strategy);\n    event LogStrategyInvest(IERC20 indexed token, uint256 amount);\n    event LogStrategyDivest(IERC20 indexed token, uint256 amount);\n    event LogStrategyProfit(IERC20 indexed token, uint256 amount);\n    event LogStrategyLoss(IERC20 indexed token, uint256 amount);\n\n    // *************** //\n    // *** STRUCTS *** //\n    // *************** //\n\n    struct StrategyData {\n        uint64 strategyStartDate;\n        uint64 targetPercentage;\n        uint128 balance; // the balance of the strategy that BentoBox thinks is in there\n    }\n\n    // ******************************** //\n    // *** CONSTANTS AND IMMUTABLES *** //\n    // ******************************** //\n\n    // V2 - Can they be private?\n    // V2: Private to save gas, to verify it's correct, check the constructor arguments\n    IERC20 private immutable wethToken;\n\n    IERC20 private constant USE_ETHEREUM = IERC20(address(0));\n    uint256 private constant FLASH_LOAN_FEE = 50; // 0.05%\n    uint256 private constant FLASH_LOAN_FEE_PRECISION = 1e5;\n    uint256 private constant STRATEGY_DELAY = 0 weeks;\n    uint256 private constant MAX_TARGET_PERCENTAGE = 95; // 95%\n    uint256 private constant MINIMUM_SHARE_BALANCE = 1000; // To prevent the ratio going off\n\n    // ***************** //\n    // *** VARIABLES *** //\n    // ***************** //\n\n    // Balance per token per address/contract in shares\n    mapping(IERC20 => mapping(address => uint256)) public balanceOf;\n\n    // Rebase from amount to share\n    mapping(IERC20 => Rebase) public totals;\n\n    mapping(IERC20 => IStrategy) public strategy;\n    mapping(IERC20 => IStrategy) public pendingStrategy;\n    mapping(IERC20 => StrategyData) public strategyData;\n\n    // ******************* //\n    // *** CONSTRUCTOR *** //\n    // ******************* //\n\n    constructor(IERC20 wethToken_) {\n        wethToken = wethToken_;\n    }\n\n    // ***************** //\n    // *** MODIFIERS *** //\n    // ***************** //\n\n    /// Modifier to check if the msg.sender is allowed to use funds belonging to the 'from' address.\n    /// If 'from' is msg.sender, it's allowed.\n    /// If 'from' is the BentoBox itself, it's allowed. Any ETH, token balances (above the known balances) or BentoBox balances\n    /// can be taken by anyone.\n    /// This is to enable skimming, not just for deposits, but also for withdrawals or transfers, enabling better composability.\n    /// If 'from' is a clone of a masterContract AND the 'from' address has approved that masterContract, it's allowed.\n    modifier allowed(address from) {\n        if (from != msg.sender && from != address(this)) {\n            // From is sender or you are skimming\n            address masterContract = masterContractOf[msg.sender];\n            require(masterContract != address(0), \"BentoBox: no masterContract\");\n            require(masterContractApproved[masterContract][from], \"BentoBox: Transfer not approved\");\n        }\n        _;\n    }\n\n    // ************************** //\n    // *** INTERNAL FUNCTIONS *** //\n    // ************************** //\n\n    /// @dev Returns the total balance of `token` this contracts holds,\n    /// plus the total amount this contract thinks the strategy holds.\n    function _tokenBalanceOf(IERC20 token) internal view returns (uint256 amount) {\n        amount = token.balanceOf(address(this)).add(strategyData[token].balance);\n    }\n\n    // ************************ //\n    // *** PUBLIC FUNCTIONS *** //\n    // ************************ //\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        IERC20 token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share) {\n        share = totals[token].toBase(amount, roundUp);\n    }\n\n    /// @dev Helper function represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        IERC20 token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount) {\n        amount = totals[token].toElastic(share, roundUp);\n    }\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token_ The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) public payable allowed(from) returns (uint256 amountOut, uint256 shareOut) {\n        // Checks\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\n\n        // Effects\n        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;\n        Rebase memory total = totals[token];\n\n        // If a new token gets added, the tokenSupply call checks that this is a deployed contract. Needed for security.\n        require(total.elastic != 0 || token.totalSupply() > 0, \"BentoBox: No tokens\");\n        if (share == 0) {\n            // value of the share may be lower than the amount due to rounding, that's ok\n            share = total.toBase(amount, false);\n            // Any deposit should lead to at least the minimum share balance, otherwise it's ignored (no amount taken)\n            if (total.base.add(share.to128()) < MINIMUM_SHARE_BALANCE) {\n                return (0, 0);\n            }\n        } else {\n            // amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)\n            amount = total.toElastic(share, true);\n        }\n\n        // In case of skimming, check that only the skimmable amount is taken.\n        // For ETH, the full balance is available, so no need to check.\n        // During flashloans the _tokenBalanceOf is lower than 'reality', so skimming deposits will mostly fail during a flashloan.\n        require(\n            from != address(this) || token_ == USE_ETHEREUM || amount <= _tokenBalanceOf(token).sub(total.elastic),\n            \"BentoBox: Skim too much\"\n        );\n\n        balanceOf[token][to] = balanceOf[token][to].add(share);\n        total.base = total.base.add(share.to128());\n        total.elastic = total.elastic.add(amount.to128());\n        totals[token] = total;\n\n        // Interactions\n        // During the first deposit, we check that this token is 'real'\n        if (token_ == USE_ETHEREUM) {\n            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)\n            // X2: If the WETH implementation is faulty or malicious, it will block adding ETH (but we know the WETH implementation)\n            IWETH(address(wethToken)).deposit{value: amount}();\n        } else if (from != address(this)) {\n            // X2 - If there is an error, could it cause a DoS. Like balanceOf causing revert. (SWC-113)\n            // X2: If the token implementation is faulty or malicious, it may block adding tokens. Good.\n            token.safeTransferFrom(from, address(this), amount);\n        }\n        emit LogDeposit(token, from, to, amount, share);\n        amountOut = amount;\n        shareOut = share;\n    }\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        IERC20 token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) public allowed(from) returns (uint256 amountOut, uint256 shareOut) {\n        // Checks\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\n\n        // Effects\n        IERC20 token = token_ == USE_ETHEREUM ? wethToken : token_;\n        Rebase memory total = totals[token];\n        if (share == 0) {\n            // value of the share paid could be lower than the amount paid due to rounding, in that case, add a share (Always round up)\n            share = total.toBase(amount, true);\n        } else {\n            // amount may be lower than the value of share due to rounding, that's ok\n            amount = total.toElastic(share, false);\n        }\n\n        balanceOf[token][from] = balanceOf[token][from].sub(share);\n        total.elastic = total.elastic.sub(amount.to128());\n        total.base = total.base.sub(share.to128());\n        // There have to be at least 1000 shares left to prevent reseting the share/amount ratio (unless it's fully emptied)\n        require(total.base >= MINIMUM_SHARE_BALANCE || total.base == 0, \"BentoBox: cannot empty\");\n        totals[token] = total;\n\n        // Interactions\n        if (token_ == USE_ETHEREUM) {\n            // X2, X3: A revert or big gas usage in the WETH contract could block withdrawals, but WETH9 is fine.\n            IWETH(address(wethToken)).withdraw(amount);\n            // X2, X3: A revert or big gas usage could block, however, the to address is under control of the caller.\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"BentoBox: ETH transfer failed\");\n        } else {\n            // X2, X3: A malicious token could block withdrawal of just THAT token.\n            //         masterContracts may want to take care not to rely on withdraw always succeeding.\n            token.safeTransfer(to, amount);\n        }\n        emit LogWithdraw(token, from, to, amount, share);\n        amountOut = amount;\n        shareOut = share;\n    }\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    // Clones of master contracts can transfer from any account that has approved them\n    // F3 - Can it be combined with another similar function?\n    // F3: This isn't combined with transferMultiple for gas optimization\n    function transfer(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 share\n    ) public allowed(from) {\n        // Checks\n        require(to != address(0), \"BentoBox: to not set\"); // To avoid a bad UI from burning funds\n\n        // Effects\n        balanceOf[token][from] = balanceOf[token][from].sub(share);\n        balanceOf[token][to] = balanceOf[token][to].add(share);\n\n        emit LogTransfer(token, from, to, share);\n    }\n\n    /// @notice Transfer shares from a user account to multiple other ones.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param tos The receivers of the tokens.\n    /// @param shares The amount of `token` in shares for each receiver in `tos`.\n    // F3 - Can it be combined with another similar function?\n    // F3: This isn't combined with transfer for gas optimization\n    function transferMultiple(\n        IERC20 token,\n        address from,\n        address[] calldata tos,\n        uint256[] calldata shares\n    ) public allowed(from) {\n        // Checks\n        require(tos[0] != address(0), \"BentoBox: to[0] not set\"); // To avoid a bad UI from burning funds\n\n        // Effects\n        uint256 totalAmount;\n        uint256 len = tos.length;\n        for (uint256 i = 0; i < len; i++) {\n            address to = tos[i];\n            balanceOf[token][to] = balanceOf[token][to].add(shares[i]);\n            totalAmount = totalAmount.add(shares[i]);\n            emit LogTransfer(token, from, to, shares[i]);\n        }\n        balanceOf[token][from] = balanceOf[token][from].sub(totalAmount);\n    }\n\n    /// @notice Flashloan ability.\n    /// @param borrower The address of the contract that implements and conforms to `IFlashBorrower` and handles the flashloan.\n    /// @param receiver Address of the token receiver.\n    /// @param token The address of the token to receive.\n    /// @param amount of the tokens to receive.\n    /// @param data The calldata to pass to the `borrower` contract.\n    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)\n    // F5: Not possible to follow this here, reentrancy has been reviewed\n    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)\n    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.\n    function flashLoan(\n        IFlashBorrower borrower,\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes calldata data\n    ) public {\n        uint256 fee = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;\n        token.safeTransfer(receiver, amount);\n\n        borrower.onFlashLoan(msg.sender, token, amount, fee, data);\n\n        require(_tokenBalanceOf(token) >= totals[token].addElastic(fee.to128()), \"BentoBox: Wrong amount\");\n        emit LogFlashLoan(address(borrower), token, amount, fee, receiver);\n    }\n\n    /// @notice Support for batched flashloans. Useful to request multiple different `tokens` in a single transaction.\n    /// @param borrower The address of the contract that implements and conforms to `IBatchFlashBorrower` and handles the flashloan.\n    /// @param receivers An array of the token receivers. A one-to-one mapping with `tokens` and `amounts`.\n    /// @param tokens The addresses of the tokens.\n    /// @param amounts of the tokens for each receiver.\n    /// @param data The calldata to pass to the `borrower` contract.\n    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)\n    // F5: Not possible to follow this here, reentrancy has been reviewed\n    // F6 - Check for front-running possibilities, such as the approve function (SWC-114)\n    // F6: Slight grieving possible by withdrawing an amount before someone tries to flashloan close to the full amount.\n    function batchFlashLoan(\n        IBatchFlashBorrower borrower,\n        address[] calldata receivers,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public {\n        uint256[] memory fees = new uint256[](tokens.length);\n\n        uint256 len = tokens.length;\n        for (uint256 i = 0; i < len; i++) {\n            uint256 amount = amounts[i];\n            fees[i] = amount.mul(FLASH_LOAN_FEE) / FLASH_LOAN_FEE_PRECISION;\n\n            tokens[i].safeTransfer(receivers[i], amounts[i]);\n        }\n\n        borrower.onBatchFlashLoan(msg.sender, tokens, amounts, fees, data);\n\n        for (uint256 i = 0; i < len; i++) {\n            IERC20 token = tokens[i];\n            require(_tokenBalanceOf(token) >= totals[token].addElastic(fees[i].to128()), \"BentoBox: Wrong amount\");\n            emit LogFlashLoan(address(borrower), token, amounts[i], fees[i], receivers[i]);\n        }\n    }\n\n    /// @notice Sets the target percentage of the strategy for `token`.\n    /// @dev Only the owner of this contract is allowed to change this.\n    /// @param token The address of the token that maps to a strategy to change.\n    /// @param targetPercentage_ The new target in percent. Must be lesser or equal to `MAX_TARGET_PERCENTAGE`.\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) public onlyOwner {\n        // Checks\n        require(targetPercentage_ <= MAX_TARGET_PERCENTAGE, \"StrategyManager: Target too high\");\n\n        // Effects\n        strategyData[token].targetPercentage = targetPercentage_;\n        emit LogStrategyTargetPercentage(token, targetPercentage_);\n    }\n\n    /// @notice Sets the contract address of a new strategy that conforms to `IStrategy` for `token`.\n    /// Must be called twice with the same arguments.\n    /// A new strategy becomes pending first and can be activated once `STRATEGY_DELAY` is over.\n    /// @dev Only the owner of this contract is allowed to change this.\n    /// @param token The address of the token that maps to a strategy to change.\n    /// @param newStrategy The address of the contract that conforms to `IStrategy`.\n    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)\n    // F5: Total amount is updated AFTER interaction. But strategy is under our control.\n    // C4 - Use block.timestamp only for long intervals (SWC-116)\n    // C4: block.timestamp is used for a period of 2 weeks, which is long enough\n    function setStrategy(IERC20 token, IStrategy newStrategy) public onlyOwner {\n        StrategyData memory data = strategyData[token];\n        IStrategy pending = pendingStrategy[token];\n        if (data.strategyStartDate == 0 || pending != newStrategy) {\n            pendingStrategy[token] = newStrategy;\n            // C1 - All math done through BoringMath (SWC-101)\n            // C1: Our sun will swallow the earth well before this overflows\n            data.strategyStartDate = (block.timestamp + STRATEGY_DELAY).to64();\n            emit LogStrategyQueued(token, newStrategy);\n        } else {\n            require(data.strategyStartDate != 0 && block.timestamp >= data.strategyStartDate, \"StrategyManager: Too early\");\n            if (address(strategy[token]) != address(0)) {\n                int256 balanceChange = strategy[token].exit(data.balance);\n                // Effects\n                if (balanceChange > 0) {\n                    uint256 add = uint256(balanceChange);\n                    totals[token].addElastic(add);\n                    emit LogStrategyProfit(token, add);\n                } else if (balanceChange < 0) {\n                    uint256 sub = uint256(-balanceChange);\n                    totals[token].subElastic(sub);\n                    emit LogStrategyLoss(token, sub);\n                }\n\n                emit LogStrategyDivest(token, data.balance);\n            }\n            strategy[token] = pending;\n            data.strategyStartDate = 0;\n            data.balance = 0;\n            pendingStrategy[token] = IStrategy(address(0));\n            emit LogStrategySet(token, newStrategy);\n        }\n        strategyData[token] = data;\n    }\n\n    /// @notice The actual process of yield farming. Executes the strategy of `token`.\n    /// Optionally does housekeeping if `balance` is true.\n    /// `maxChangeAmount` is relevant for skimming or withdrawing if `balance` is true.\n    /// @param token The address of the token for which a strategy is deployed.\n    /// @param balance True if housekeeping should be done.\n    /// @param maxChangeAmount The maximum amount for either pulling or pushing from/to the `IStrategy` contract.\n    // F5 - Checks-Effects-Interactions pattern followed? (SWC-107)\n    // F5: Total amount is updated AFTER interaction. But strategy is under our control.\n    // F5: Not followed to prevent reentrancy issues with flashloans and BentoBox skims?\n    function harvest(\n        IERC20 token,\n        bool balance,\n        uint256 maxChangeAmount\n    ) public {\n        StrategyData memory data = strategyData[token];\n        IStrategy _strategy = strategy[token];\n        int256 balanceChange = _strategy.harvest(data.balance, msg.sender);\n        if (balanceChange == 0 && !balance) {\n            return;\n        }\n\n        uint256 totalElastic = totals[token].elastic;\n\n        if (balanceChange > 0) {\n            uint256 add = uint256(balanceChange);\n            totalElastic = totalElastic.add(add);\n            totals[token].elastic = totalElastic.to128();\n            emit LogStrategyProfit(token, add);\n        } else if (balanceChange < 0) {\n            // C1 - All math done through BoringMath (SWC-101)\n            // C1: balanceChange could overflow if it's max negative int128.\n            // But tokens with balances that large are not supported by the BentoBox.\n            uint256 sub = uint256(-balanceChange);\n            totalElastic = totalElastic.sub(sub);\n            totals[token].elastic = totalElastic.to128();\n            data.balance = data.balance.sub(sub.to128());\n            emit LogStrategyLoss(token, sub);\n        }\n\n        if (balance) {\n            uint256 targetBalance = totalElastic.mul(data.targetPercentage) / 100;\n            // if data.balance == targetBalance there is nothing to update\n            if (data.balance < targetBalance) {\n                uint256 amountOut = targetBalance.sub(data.balance);\n                if (maxChangeAmount != 0 && amountOut > maxChangeAmount) {\n                    amountOut = maxChangeAmount;\n                }\n                token.safeTransfer(address(_strategy), amountOut);\n                data.balance = data.balance.add(amountOut.to128());\n                _strategy.skim(amountOut);\n                emit LogStrategyInvest(token, amountOut);\n            } else if (data.balance > targetBalance) {\n                uint256 amountIn = data.balance.sub(targetBalance.to128());\n                if (maxChangeAmount != 0 && amountIn > maxChangeAmount) {\n                    amountIn = maxChangeAmount;\n                }\n\n                uint256 actualAmountIn = _strategy.withdraw(amountIn);\n\n                data.balance = data.balance.sub(actualAmountIn.to128());\n                emit LogStrategyDivest(token, actualAmountIn);\n            }\n        }\n\n        strategyData[token] = data;\n    }\n\n    // Contract should be able to receive ETH deposits to support deposit & skim\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interfaces/IPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice Trident pool deployment interface.\ninterface IPoolFactory {\n    function deployPool(bytes calldata _deployData) external returns (address pool);\n\n    function configAddress(bytes32 data) external returns (address pool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/mocks/ERC20PermitAllowedMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >= 0.8.0;\n\nimport \"./ERC20Mock.sol\";\nimport \"../interfaces/IERC20PermitAllowed.sol\";\n\ncontract ERC20PermitAllowedMock is ERC20Mock, IERC20PermitAllowed {\n    constructor(uint256 supply) ERC20Mock(\"Mock\", \"MOCK\", supply) {}\n\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(this.nonces(holder) == nonce, \"ERC20PermitAllowedMock::permit: wrong nonce\");\n        permit(holder, spender, allowed ? type(uint256).max : 0, expiry, v, r, s);\n    }\n}"
    },
    "contracts/interfaces/IERC20PermitAllowed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\ninterface IERC20PermitAllowed {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}"
    },
    "contracts/abstract/SelfPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\nimport \"../interfaces/IERC20PermitAllowed.sol\";\n\nabstract contract SelfPermit {\n    function selfPermit(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable {\n        IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);\n    }\n\n    function selfPermitIfNecessary(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable {\n        if (IERC20(token).allowance(msg.sender, address(this)) < value) selfPermit(token, value, deadline, v, r, s);\n    }\n\n    function selfPermitAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public payable {\n        IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n    }\n\n    function selfPermitAllowedIfNecessary(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable {\n        if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max)\n            selfPermitAllowed(token, nonce, expiry, v, r, s);\n    }\n}"
    },
    "contracts/mocks/SelfPermitMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >= 0.8.0;\n\nimport \"../abstract/SelfPermit.sol\";\n\ncontract SelfPermitMock is SelfPermit {}\n"
    },
    "contracts/TridentRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport {Multicall} from \"./abstract/Multicall.sol\";\nimport {SelfPermit} from \"./abstract/SelfPermit.sol\";\nimport {Transfer} from \"./libraries/Transfer.sol\";\nimport {IBentoBoxMinimal} from \"./interfaces/IBentoBoxMinimal.sol\";\nimport {IMasterDeployer} from \"./interfaces/IMasterDeployer.sol\";\nimport {IPool} from \"./interfaces/IPool.sol\";\nimport {ITridentRouter} from \"./interfaces/ITridentRouter.sol\";\nimport {IWETH9} from \"./interfaces/IWETH9.sol\";\n\n/// @dev Custom Errors\nerror NotWethSender();\nerror TooLittleReceived();\nerror NotEnoughLiquidityMinted();\nerror IncorrectTokenWithdrawn();\nerror InsufficientWETH();\nerror InvalidPool();\n\n/// @notice Router contract that helps in swapping across Trident pools.\ncontract TridentRouter is ITridentRouter, SelfPermit, Multicall {\n    using Transfer for address;\n\n    /// @dev Cached whitelisted pools.\n    mapping(address => bool) internal whitelistedPools;\n\n    /// @notice BentoBox token vault.\n    IBentoBoxMinimal public immutable bento;\n    \n    /// @notice Master deployer.\n    IMasterDeployer public immutable masterDeployer;\n\n    /// @notice ERC-20 token for wrapped ETH (v9).\n    address internal immutable wETH;\n    \n    /// @notice The user should use 0x0 if they want to use native currency, e.g., ETH.\n    address constant USE_NATIVE = address(0);\n\n    constructor(\n        IBentoBoxMinimal _bento,\n        IMasterDeployer _masterDeployer,\n        address _wETH\n    ) {\n        bento = _bento;\n        masterDeployer = _masterDeployer;\n        wETH = _wETH;\n        _bento.registerProtocol();\n    }\n\n    receive() external payable {\n        if (msg.sender != wETH) revert NotWethSender();\n    }\n\n    /// @notice Swaps token A to token B directly. Swaps are done on `bento` tokens.\n    /// @param params This includes the address of token A, pool, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pool for the swap.\n    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.\n    function exactInputSingle(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {\n        // Prefund the pool with token A.\n        bento.transfer(params.tokenIn, msg.sender, params.pool, params.amountIn);\n        // Trigger the swap in the pool.\n        amountOut = IPool(params.pool).swap(params.data);\n        // Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        if (amountOut < params.amountOutMinimum) revert TooLittleReceived();\n    }\n\n    /// @notice Swaps token A to token B indirectly by using multiple hops.\n    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pools for the swaps.\n    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.\n    function exactInput(ExactInputParams calldata params) public payable returns (uint256 amountOut) {\n        // Pay the first pool directly.\n        bento.transfer(params.tokenIn, msg.sender, params.path[0].pool, params.amountIn);\n        // Call every pool in the path.\n        // Pool `N` should transfer its output tokens to pool `N+1` directly.\n        // The last pool should transfer its output tokens to the user.\n        // If the user wants to unwrap `wETH`, the final destination should be this contract and\n        // a batch call should be made to `unwrapWETH`.\n        for (uint256 i; i < params.path.length; ) {\n            // We don't necessarily need this check but saving users from themselves.\n            isWhiteListed(params.path[i].pool);\n            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);\n            unchecked {\n                ++i;\n            }\n        }\n        // Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        if (amountOut < params.amountOutMinimum) revert TooLittleReceived();\n    }\n\n    /// @notice Swaps token A to token B directly. It's the same as `exactInputSingle` except\n    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.\n    /// @param params This includes the address of token A, pool, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pool for the swap.\n    /// @dev Ensure that the pool is trusted before calling this function. The pool can steal users' tokens.\n    function exactInputSingleWithNativeToken(ExactInputSingleParams calldata params) public payable returns (uint256 amountOut) {\n        // Deposits the native ERC-20 token from the user into the pool's `bento`.\n        _depositToBentoBox(params.tokenIn, params.pool, params.amountIn);\n        // Trigger the swap in the pool.\n        amountOut = IPool(params.pool).swap(params.data);\n        // Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        if (amountOut < params.amountOutMinimum) revert TooLittleReceived();\n    }\n\n    /// @notice Swaps token A to token B indirectly by using multiple hops. It's the same as `exactInput` except\n    /// it takes raw ERC-20 tokens from the users and deposits them into `bento`.\n    /// @param params This includes the addresses of the tokens, pools, amount of token A to swap,\n    /// minimum amount of token B after the swap and data required by the pools for the swaps.\n    /// @dev Ensure that the pools are trusted before calling this function. The pools can steal users' tokens.\n    function exactInputWithNativeToken(ExactInputParams calldata params) public payable returns (uint256 amountOut) {\n        // Deposits the native ERC-20 token from the user into the pool's `bento`.\n        _depositToBentoBox(params.tokenIn, params.path[0].pool, params.amountIn);\n        // Call every pool in the path.\n        // Pool `N` should transfer its output tokens to pool `N+1` directly.\n        // The last pool should transfer its output tokens to the user.\n        for (uint256 i; i < params.path.length; ) {\n            isWhiteListed(params.path[i].pool);\n            amountOut = IPool(params.path[i].pool).swap(params.path[i].data);\n            unchecked {\n                ++i;\n            }\n        }\n        // Ensure that the slippage wasn't too much. This assumes that the pool is honest.\n        if (amountOut < params.amountOutMinimum) revert TooLittleReceived();\n    }\n\n    /// @notice Swaps multiple input tokens to multiple output tokens using multiple paths, in different percentages.\n    /// For example, you can swap 50 DAI + 100 USDC into 60% ETH and 40% BTC.\n    /// @param params This includes everything needed for the swap. Look at the `ComplexPathParams` struct for more details.\n    /// @dev This function is not optimized for single swaps and should only be used in complex cases where\n    /// the amounts are large enough that minimizing slippage by using multiple paths is worth the extra gas.\n    function complexPath(ComplexPathParams calldata params) public payable {\n        // Deposit all initial tokens to respective pools and initiate the swaps.\n        // Input tokens come from the user - output goes to following pools.\n        for (uint256 i; i < params.initialPath.length; ) {\n            if (params.initialPath[i].native) {\n                _depositToBentoBox(params.initialPath[i].tokenIn, params.initialPath[i].pool, params.initialPath[i].amount);\n            } else {\n                bento.transfer(params.initialPath[i].tokenIn, msg.sender, params.initialPath[i].pool, params.initialPath[i].amount);\n            }\n            isWhiteListed(params.initialPath[i].pool);\n            IPool(params.initialPath[i].pool).swap(params.initialPath[i].data);\n            unchecked {\n                ++i;\n            }\n        }\n        // Do all the middle swaps. Input comes from previous pools - output goes to following pools.\n        for (uint256 i; i < params.percentagePath.length; ) {\n            uint256 balanceShares = bento.balanceOf(params.percentagePath[i].tokenIn, address(this));\n            uint256 transferShares = (balanceShares * params.percentagePath[i].balancePercentage) / uint256(10)**8;\n            bento.transfer(params.percentagePath[i].tokenIn, address(this), params.percentagePath[i].pool, transferShares);\n            isWhiteListed(params.percentagePath[i].pool);\n            IPool(params.percentagePath[i].pool).swap(params.percentagePath[i].data);\n            unchecked {\n                ++i;\n            }\n        }\n        // Do all the final swaps. Input comes from previous pools - output goes to the user.\n        for (uint256 i; i < params.output.length; ) {\n            uint256 balanceShares = bento.balanceOf(params.output[i].token, address(this));\n            if (balanceShares < params.output[i].minAmount) revert TooLittleReceived();\n            if (params.output[i].unwrapBento) {\n                bento.withdraw(params.output[i].token, address(this), params.output[i].to, 0, balanceShares);\n            } else {\n                bento.transfer(params.output[i].token, address(this), params.output[i].to, balanceShares);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Add liquidity to a pool.\n    /// @param tokenInput Token address and amount to add as liquidity.\n    /// @param pool Pool address to add liquidity to.\n    /// @param minLiquidity Minimum output liquidity - caps slippage.\n    /// @param data Data required by the pool to add liquidity.\n    function addLiquidity(\n        TokenInput[] calldata tokenInput,\n        address pool,\n        uint256 minLiquidity,\n        bytes calldata data\n    ) public payable returns (uint256 liquidity) {\n        isWhiteListed(pool);\n        // Send all input tokens to the pool.\n        for (uint256 i; i < tokenInput.length; ) {\n            if (tokenInput[i].native) {\n                _depositToBentoBox(tokenInput[i].token, pool, tokenInput[i].amount);\n            } else {\n                bento.transfer(tokenInput[i].token, msg.sender, pool, tokenInput[i].amount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        liquidity = IPool(pool).mint(data);\n        if (liquidity < minLiquidity) revert NotEnoughLiquidityMinted();\n    }\n\n    /// @notice Burn liquidity tokens to get back `bento` tokens.\n    /// @param pool Pool address.\n    /// @param liquidity Amount of liquidity tokens to burn.\n    /// @param data Data required by the pool to burn liquidity.\n    /// @param minWithdrawals Minimum amount of `bento` tokens to be returned.\n    function burnLiquidity(\n        address pool,\n        uint256 liquidity,\n        bytes calldata data,\n        IPool.TokenAmount[] calldata minWithdrawals\n    ) public {\n        isWhiteListed(pool);\n        pool.safeTransferFrom(msg.sender, pool, liquidity);\n        IPool.TokenAmount[] memory withdrawnLiquidity = IPool(pool).burn(data);\n        for (uint256 i; i < minWithdrawals.length; ++i) {\n            uint256 j;\n            for (; j < withdrawnLiquidity.length; ++j) {\n                if (withdrawnLiquidity[j].token == minWithdrawals[i].token) {\n                    if (withdrawnLiquidity[j].amount < minWithdrawals[i].amount) revert TooLittleReceived();\n                    break;\n                }\n            }\n            // A token that is present in `minWithdrawals` is missing from `withdrawnLiquidity`.\n            if (j >= withdrawnLiquidity.length) revert IncorrectTokenWithdrawn();\n        }\n    }\n\n    /// @notice Burn liquidity tokens to get back `bento` tokens.\n    /// @dev The tokens are swapped automatically and the output is in a single token.\n    /// @param pool Pool address.\n    /// @param liquidity Amount of liquidity tokens to burn.\n    /// @param data Data required by the pool to burn liquidity.\n    /// @param minWithdrawal Minimum amount of tokens to be returned.\n    function burnLiquiditySingle(\n        address pool,\n        uint256 liquidity,\n        bytes calldata data,\n        uint256 minWithdrawal\n    ) public {\n        isWhiteListed(pool);\n        // Use 'liquidity = 0' for prefunding.\n        pool.safeTransferFrom(msg.sender, pool, liquidity);\n        uint256 withdrawn = IPool(pool).burnSingle(data);\n        if (withdrawn < minWithdrawal) revert TooLittleReceived();\n    }\n\n    /// @notice Recover mistakenly sent tokens.\n    function sweep(\n        address token,\n        uint256 amount,\n        address recipient,\n        bool onBento\n    ) external payable {\n        if (onBento) {\n            bento.transfer(token, address(this), recipient, amount);\n        } else {\n            token == USE_NATIVE ? recipient.safeTransferETH(address(this).balance) : token.safeTransfer(recipient, amount);\n        }\n    }\n\n    /// @notice Unwrap this contract's `wETH` into ETH.\n    function unwrapWETH(uint256 amountMinimum, address recipient) external payable {\n        uint256 balance = IWETH9(wETH).balanceOf(address(this));\n        if (balance < amountMinimum) revert InsufficientWETH();\n        if (balance != 0) {\n            IWETH9(wETH).withdraw(balance);\n            recipient.safeTransferETH(balance);\n        }\n    }\n\n   /// @notice Wrapper function to allow pool deployment to be batched. \n    function deployPool(address factory, bytes calldata deployData) external payable returns (address) {\n        return masterDeployer.deployPool(factory, deployData);\n    }\n\n    /// @notice Wrapper function to allow bento set master contract approval to be batched, so the first trade can happen in one transaction.\n    function approveMasterContract(\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable {\n        bento.setMasterContractApproval(msg.sender, address(this), true, v, r, s);\n    }\n\n    /// @notice Deposit from the user's wallet into BentoBox.\n    /// @dev Amount is the native token amount. We let BentoBox do the conversion into shares.\n    function _depositToBentoBox(\n        address token,\n        address recipient,\n        uint256 amount\n    ) internal {\n        bento.deposit{value: token == USE_NATIVE ? amount : 0}(token, msg.sender, recipient, amount, 0);\n    }\n    \n    /// @notice Check pool whitelisting status.\n    function isWhiteListed(address pool) internal {\n        if (!whitelistedPools[pool]) {\n            if (!masterDeployer.pools(pool)) revert InvalidPool();\n            whitelistedPools[pool] = true;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Transfer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary Transfer {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) =\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"STF\");\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ST\");\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SA\");\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"STE\");\n    }\n}"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\ninterface IWETH9 is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256) external;\n}"
    },
    "contracts/pool/hybrid/HybridPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/IBentoBoxMinimal.sol\";\nimport \"../../interfaces/IMasterDeployer.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../interfaces/ITridentCallee.sol\";\nimport \"../../libraries/MathUtils.sol\";\nimport \"../../libraries/RebaseLibrary.sol\";\n\n\n/// @notice Trident exchange pool template with hybrid like-kind formula for swapping between an ERC-20 token pair.\n/// @dev The reserves are stored as bento shares. However, the stableswap invariant is applied to the underlying amounts.\n///      The API uses the underlying amounts.\ncontract HybridPool is IPool, ERC20, ReentrancyGuard {\n    using MathUtils for uint256;\n    using RebaseLibrary for Rebase;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient, uint256 liquidity);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient, uint256 liquidity);\n    event Sync(uint256 reserve0, uint256 reserve1);\n\n    uint256 internal constant MINIMUM_LIQUIDITY = 10**3;\n    uint8 internal constant PRECISION = 112;\n\n    /// @dev Constant value used as max loop limit.\n    uint256 private constant MAX_LOOP_LIMIT = 256;\n    uint256 internal constant MAX_FEE = 10000; // @dev 100%.\n    uint256 public immutable swapFee;\n\n    IBentoBoxMinimal public immutable bento;\n    IMasterDeployer public immutable masterDeployer;\n    address public immutable barFeeTo;\n    address public immutable token0;\n    address public immutable token1;\n    uint256 public immutable A;\n    uint256 internal immutable N_A; // @dev 2 * A.\n    uint256 internal constant A_PRECISION = 100;\n\n    /// @dev Multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS.\n    /// For example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\n    /// has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10.\n    uint256 public immutable token0PrecisionMultiplier;\n    uint256 public immutable token1PrecisionMultiplier;\n\n    uint256 public barFee;\n\n    uint128 internal reserve0;\n    uint128 internal reserve1;\n    uint256 internal dLast;\n\n    bytes32 public constant override poolIdentifier = \"Trident:HybridPool\";\n\n    constructor(bytes memory _deployData, address _masterDeployer) ERC20(\"Sushi LP Token\", \"SLP\", 18) {\n        (address _token0, address _token1, uint256 _swapFee, uint256 a) = abi.decode(_deployData, (address, address, uint256, uint256));\n\n        // @dev Factory ensures that the tokens are sorted.\n        require(_token0 != address(0), \"ZERO_ADDRESS\");\n        require(_token0 != _token1, \"IDENTICAL_ADDRESSES\");\n        require(_swapFee <= MAX_FEE, \"INVALID_SWAP_FEE\");\n        require(a != 0, \"ZERO_A\");\n\n        token0 = _token0;\n        token1 = _token1;\n        swapFee = _swapFee;\n        barFee = IMasterDeployer(_masterDeployer).barFee();\n        barFeeTo = IMasterDeployer(_masterDeployer).barFeeTo();\n        bento = IBentoBoxMinimal(IMasterDeployer(_masterDeployer).bento());\n        masterDeployer = IMasterDeployer(_masterDeployer);\n        A = a;\n        N_A = 2 * a;\n        token0PrecisionMultiplier = uint256(10)**(18 - ERC20(_token0).decimals());\n        token1PrecisionMultiplier = uint256(10)**(18 - ERC20(_token1).decimals());\n    }\n\n    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.\n    /// The router must ensure that sufficient LP tokens are minted by using the return value.\n    function mint(bytes calldata data) public override nonReentrant returns (uint256 liquidity) {\n        address recipient = abi.decode(data, (address));\n        (uint256 _reserve0, uint256 _reserve1) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n\n        uint256 newLiq = _computeLiquidity(balance0, balance1);\n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);\n        _reserve0 += uint112(fee0);\n        _reserve1 += uint112(fee1);\n\n        (uint256 _totalSupply, uint256 oldLiq) = _mintFee(_reserve0, _reserve1);\n\n        if (_totalSupply == 0) {\n            require(amount0 > 0 && amount1 > 0, \"INVALID_AMOUNTS\");\n            liquidity = newLiq - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY);\n        } else {\n            liquidity = ((newLiq - oldLiq) * _totalSupply) / oldLiq;\n        }\n        require(liquidity != 0, \"INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(recipient, liquidity);\n        _updateReserves();\n\n        dLast = newLiq;\n        uint256 liquidityForEvent = liquidity;\n        emit Mint(msg.sender, amount0, amount1, recipient, liquidityForEvent);\n    }\n\n    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.\n    function burn(bytes calldata data) public override nonReentrant returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 liquidity = balanceOf[address(this)];\n\n        (uint256 _totalSupply, ) = _mintFee(balance0, balance1);\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        _burn(address(this), liquidity);\n        _transfer(token0, amount0, recipient, unwrapBento);\n        _transfer(token1, amount1, recipient, unwrapBento);\n\n        _updateReserves();\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n\n        dLast = _computeLiquidity(balance0 - amount0, balance1 - amount1);\n\n        emit Burn(msg.sender, amount0, amount1, recipient, liquidity);\n    }\n\n    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another\n    /// - i.e., the user gets a single token out by burning LP tokens.\n    function burnSingle(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 liquidity = balanceOf[address(this)];\n\n        (uint256 _totalSupply, ) = _mintFee(balance0, balance1);\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        _burn(address(this), liquidity);\n        dLast = _computeLiquidity(balance0 - amount0, balance1 - amount1);\n\n        // Swap tokens\n        if (tokenOut == token1) {\n            // @dev Swap `token0` for `token1`.\n            // @dev Calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.\n            amount1 += _getAmountOut(amount0, balance0 - amount0, balance1 - amount1, true);\n            _transfer(token1, amount1, recipient, unwrapBento);\n            amountOut = amount1;\n            amount0 = 0;\n        } else {\n            // @dev Swap `token1` for `token0`.\n            require(tokenOut == token0, \"INVALID_OUTPUT_TOKEN\");\n            amount0 += _getAmountOut(amount1, balance0 - amount0, balance1 - amount1, false);\n            _transfer(token0, amount0, recipient, unwrapBento);\n            amountOut = amount0;\n            amount1 = 0;\n        }\n        _updateReserves();\n        emit Burn(msg.sender, amount0, amount1, recipient, liquidity);\n    }\n\n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\n    function swap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint256 _reserve0, uint256 _reserve1, uint256 balance0, uint256 balance1) = _getReservesAndBalances();\n        uint256 amountIn;\n        address tokenOut;\n\n        if (tokenIn == token0) {\n            tokenOut = token1;\n            unchecked {\n                amountIn = balance0 - _reserve0;\n            }\n            amountOut = _getAmountOut(amountIn, _reserve0, _reserve1, true);\n        } else {\n            require(tokenIn == token1, \"INVALID_INPUT_TOKEN\");\n            tokenOut = token0;\n            unchecked {\n                amountIn = balance1 - _reserve1;\n            }\n            amountOut = _getAmountOut(amountIn, _reserve0, _reserve1, false);\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        _updateReserves();\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n\n    /// @dev Swaps one token for another with payload. The router must support swap callbacks and ensure there isn't too much slippage.\n    function flashSwap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(\n            data,\n            (address, address, bool, uint256, bytes)\n        );\n        (uint256 _reserve0, uint256 _reserve1) = _getReserves();\n        address tokenOut;\n\n        if (tokenIn == token0) {\n            tokenOut = token1;\n            amountIn = bento.toAmount(token0, amountIn, false);\n            amountOut = _getAmountOut(amountIn, _reserve0, _reserve1, true);\n            _processSwap(token1, recipient, amountOut, context, unwrapBento);\n            uint256 balance0 = bento.toAmount(token0, bento.balanceOf(token0, address(this)), false);\n            require(balance0 - _reserve0 >= amountIn, \"INSUFFICIENT_AMOUNT_IN\");\n        } else {\n            require(tokenIn == token1, \"INVALID_INPUT_TOKEN\");\n            tokenOut = token0;\n            amountIn = bento.toAmount(token1, amountIn, false);\n            amountOut = _getAmountOut(amountIn, _reserve0, _reserve1, false);\n            _processSwap(token0, recipient, amountOut, context, unwrapBento);\n            uint256 balance1 = bento.toAmount(token1, bento.balanceOf(token1, address(this)), false);\n            require(balance1 - _reserve1 >= amountIn, \"INSUFFICIENT_AMOUNT_IN\");\n        }\n        _updateReserves();\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n\n    /// @dev Updates `barFee` for Trident protocol.\n    function updateBarFee() public {\n        barFee = masterDeployer.barFee();\n    }\n\n    function _processSwap(\n        address tokenOut,\n        address to,\n        uint256 amountOut,\n        bytes memory data,\n        bool unwrapBento\n    ) internal {\n        _transfer(tokenOut, amountOut, to, unwrapBento);\n        if (data.length != 0) ITridentCallee(msg.sender).tridentSwapCallback(data);\n    }\n\n    function _getReserves() internal view returns (uint256 _reserve0, uint256 _reserve1) {\n        (_reserve0, _reserve1) = (reserve0, reserve1);\n        _reserve0 = bento.toAmount(token0, _reserve0, false);\n        _reserve1 = bento.toAmount(token1, _reserve1, false);\n    }\n\n    function _getReservesAndBalances()\n        internal\n        view\n        returns (\n            uint256 _reserve0,\n            uint256 _reserve1,\n            uint256 balance0,\n            uint256 balance1\n        )\n    {\n        (_reserve0, _reserve1) = (reserve0, reserve1);\n        balance0 = bento.balanceOf(token0, address(this));\n        balance1 = bento.balanceOf(token1, address(this));\n        Rebase memory total0 = bento.totals(token0);\n        Rebase memory total1 = bento.totals(token1);\n\n        _reserve0 = total0.toElastic(_reserve0);\n        _reserve1 = total1.toElastic(_reserve1);\n        balance0 = total0.toElastic(balance0);\n        balance1 = total1.toElastic(balance1);\n    }\n\n    function _updateReserves() internal {\n        (uint256 _reserve0, uint256 _reserve1) = _balance();\n        require(_reserve0 <= type(uint128).max && _reserve1 <= type(uint128).max, \"OVERFLOW\");\n        reserve0 = uint128(_reserve0);\n        reserve1 = uint128(_reserve1);\n        emit Sync(_reserve0, _reserve1);\n    }\n\n    function _balance() internal view returns (uint256 balance0, uint256 balance1) {\n        balance0 = bento.toAmount(token0, bento.balanceOf(token0, address(this)), false);\n        balance1 = bento.toAmount(token1, bento.balanceOf(token1, address(this)), false);\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 _reserve0,\n        uint256 _reserve1,\n        bool token0In\n    ) internal view returns (uint256 dy) {\n        unchecked {\n            uint256 adjustedReserve0 = _reserve0 * token0PrecisionMultiplier;\n            uint256 adjustedReserve1 = _reserve1 * token1PrecisionMultiplier;\n            uint256 feeDeductedAmountIn = amountIn - (amountIn * swapFee) / MAX_FEE;\n            uint256 d = _computeLiquidityFromAdjustedBalances(adjustedReserve0, adjustedReserve1);\n\n            if (token0In) {\n                uint256 x = adjustedReserve0 + (feeDeductedAmountIn * token0PrecisionMultiplier);\n                uint256 y = _getY(x, d);\n                dy = adjustedReserve1 - y - 1;\n                dy /= token1PrecisionMultiplier;\n            } else {\n                uint256 x = adjustedReserve1 + (feeDeductedAmountIn * token1PrecisionMultiplier);\n                uint256 y = _getY(x, d);\n                dy = adjustedReserve0 - y - 1;\n                dy /= token0PrecisionMultiplier;\n            }\n        }\n    }\n\n    function _transfer(\n        address token,\n        uint256 amount,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, address(this), to, amount, 0);\n        } else {\n            bento.transfer(token, address(this), to, bento.toShare(token, amount, false));\n        }\n    }\n\n    /// @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\n    /// See the StableSwap paper for details.\n    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L319.\n    /// @return liquidity The invariant, at the precision of the pool.\n    function _computeLiquidity(uint256 _reserve0, uint256 _reserve1) internal view returns (uint256 liquidity) {\n        unchecked {\n            uint256 adjustedReserve0 = _reserve0 * token0PrecisionMultiplier;\n            uint256 adjustedReserve1 = _reserve1 * token1PrecisionMultiplier;\n            liquidity = _computeLiquidityFromAdjustedBalances(adjustedReserve0, adjustedReserve1);\n        }\n    }\n\n    function _computeLiquidityFromAdjustedBalances(uint256 xp0, uint256 xp1) internal view returns (uint256 computed) {\n        uint256 s = xp0 + xp1;\n\n        if (s == 0) {\n            computed = 0;\n        }\n        uint256 prevD;\n        uint256 D = s;\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            uint256 dP = (((D * D) / xp0) * D) / xp1 / 4;\n            prevD = D;\n            D = (((N_A * s) / A_PRECISION + 2 * dP) * D) / ((N_A / A_PRECISION - 1) * D + 3 * dP);\n            if (D.within1(prevD)) {\n                break;\n            }\n        }\n        computed = D;\n    }\n\n    /// @notice Calculate the new balances of the tokens given the indexes of the token\n    /// that is swapped from (FROM) and the token that is swapped to (TO).\n    /// This function is used as a helper function to calculate how much TO token\n    /// the user should receive on swap.\n    /// @dev Originally https://github.com/saddle-finance/saddle-contract/blob/0b76f7fb519e34b878aa1d58cffc8d8dc0572c12/contracts/SwapUtils.sol#L432.\n    /// @param x The new total amount of FROM token.\n    /// @return y The amount of TO token that should remain in the pool.\n    function _getY(uint256 x, uint256 D) internal view returns (uint256 y) {\n        uint256 c = (D * D) / (x * 2);\n        c = (c * D) / ((N_A * 2) / A_PRECISION);\n        uint256 b = x + ((D * A_PRECISION) / N_A);\n        uint256 yPrev;\n        y = D;\n        // @dev Iterative approximation.\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\n            yPrev = y;\n            y = (y * y + c) / (y * 2 + b - D);\n            if (y.within1(yPrev)) {\n                break;\n            }\n        }\n    }\n\n    function _mintFee(uint256 _reserve0, uint256 _reserve1) internal returns (uint256 _totalSupply, uint256 d) {\n        _totalSupply = totalSupply;\n        uint256 _dLast = dLast;\n        if (_dLast != 0) {\n            d = _computeLiquidity(_reserve0, _reserve1);\n            if (d > _dLast) {\n                // @dev `barFee` % of increase in liquidity.\n                uint256 _barFee = barFee;\n                uint256 numerator = _totalSupply * (d - _dLast) * _barFee;\n                uint256 denominator = (MAX_FEE - _barFee) * d + _barFee * _dLast;\n                uint256 liquidity = numerator / denominator;\n\n                if (liquidity != 0) {\n                    _mint(barFeeTo, liquidity);\n                    _totalSupply += liquidity;\n                }\n            }\n        }\n    }\n\n    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.\n    function _nonOptimalMintFee(\n        uint256 _amount0,\n        uint256 _amount1,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {\n        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);\n        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;\n\n        if (amount1Optimal <= _amount1) {\n            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);\n        } else {\n            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;\n            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);\n        }\n    }\n\n    function getAssets() public view override returns (address[] memory assets) {\n        assets = new address[](2);\n        assets[0] = token0;\n        assets[1] = token1;\n    }\n\n    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {\n        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));\n        (uint256 _reserve0, uint256 _reserve1) = _getReserves();\n        amountIn = bento.toAmount(tokenIn, amountIn, false);\n\n        if (tokenIn == token0) {\n            finalAmountOut = bento.toShare(token1, _getAmountOut(amountIn, _reserve0, _reserve1, true), false);\n        } else {\n            require(tokenIn == token1, \"INVALID_INPUT_TOKEN\");\n            finalAmountOut = bento.toShare(token0, _getAmountOut(amountIn, _reserve0, _reserve1, false), false);\n        }\n    }\n\n    function getAmountIn(bytes calldata) public pure override returns (uint256) {\n        revert();\n    }\n\n    function getReserves() public view returns (uint256 _reserve0, uint256 _reserve1) {\n        (_reserve0, _reserve1) = _getReserves();\n    }\n\n    function getVirtualPrice() public view returns (uint256 virtualPrice) {\n        (uint256 _reserve0, uint256 _reserve1) = _getReserves();\n        uint256 d = _computeLiquidity(_reserve0, _reserve1);\n        virtualPrice = (d * (uint256(10)**decimals)) / totalSupply;\n    }\n}\n"
    },
    "contracts/libraries/MathUtils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\n/// @notice A library that contains functions for calculating differences between two uint256.\n/// @author Adapted from https://github.com/saddle-finance/saddle-contract/blob/master/contracts/MathUtils.sol.\nlibrary MathUtils {\n    /// @notice Compares a and b and returns 'true' if the difference between a and b\n    /// is less than 1 or equal to each other.\n    /// @param a uint256 to compare with.\n    /// @param b uint256 to compare with.\n    function within1(uint256 a, uint256 b) internal pure returns (bool) {\n        unchecked {\n            if (a > b) {\n                return a - b <= 1;\n            }\n            return b - a <= 1;\n        }\n    }\n}\n"
    },
    "contracts/pool/hybrid/HybridPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./HybridPool.sol\";\nimport \"../../abstract/PoolDeployer.sol\";\n\n/// @notice Contract for deploying Trident exchange Hybrid Pool with configurations.\n/// @author Mudit Gupta.\ncontract HybridPoolFactory is PoolDeployer {\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n\n    function deployPool(bytes memory _deployData) external returns (address pool) {\n        (address tokenA, address tokenB, uint256 swapFee, uint256 a) = abi.decode(_deployData, (address, address, uint256, uint256));\n\n        if (tokenA > tokenB) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n\n        // @dev Strips any extra data.\n        _deployData = abi.encode(tokenA, tokenB, swapFee, a);\n        address[] memory tokens = new address[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.\n        bytes32 salt = keccak256(_deployData);\n        pool = address(new HybridPool{salt: salt}(_deployData, masterDeployer));\n        _registerPool(pool, tokens, salt);\n    }\n}\n"
    },
    "contracts/pool/index/IndexPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IBentoBoxMinimal.sol\";\nimport \"../../interfaces/IMasterDeployer.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../interfaces/ITridentCallee.sol\";\nimport \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\n/// @notice Trident exchange pool template with constant mean formula for swapping among an array of ERC-20 tokens.\n/// @dev The reserves are stored as bento shares.\n///      The curve is applied to shares as well. This pool does not care about the underlying amounts.\ncontract IndexPool is IPool, ERC20, ReentrancyGuard {\n    event Mint(address indexed sender, address tokenIn, uint256 amountIn, address indexed recipient);\n    event Burn(address indexed sender, address tokenOut, uint256 amountOut, address indexed recipient);\n\n    uint256 public immutable swapFee;\n\n    address public immutable barFeeTo;\n    IBentoBoxMinimal public immutable bento;\n    IMasterDeployer public immutable masterDeployer;\n\n    uint256 internal constant BASE = 10**18;\n    uint256 internal constant MIN_TOKENS = 2;\n    uint256 internal constant MAX_TOKENS = 8;\n    uint256 internal constant MIN_FEE = BASE / 10**6;\n    uint256 internal constant MAX_FEE = BASE / 10;\n    uint256 internal constant MIN_WEIGHT = BASE;\n    uint256 internal constant MAX_WEIGHT = BASE * 50;\n    uint256 internal constant MAX_TOTAL_WEIGHT = BASE * 50;\n    uint256 internal constant MIN_BALANCE = BASE / 10**12;\n    uint256 internal constant INIT_POOL_SUPPLY = BASE * 100;\n    uint256 internal constant MIN_POW_BASE = 1;\n    uint256 internal constant MAX_POW_BASE = (2 * BASE) - 1;\n    uint256 internal constant POW_PRECISION = BASE / 10**10;\n    uint256 internal constant MAX_IN_RATIO = BASE / 2;\n    uint256 internal constant MAX_OUT_RATIO = (BASE / 3) + 1;\n\n    uint136 internal totalWeight;\n    address[] internal tokens;\n\n    uint256 public barFee;\n\n    bytes32 public constant override poolIdentifier = \"Trident:Index\";\n\n    mapping(address => Record) public records;\n    struct Record {\n        uint120 reserve;\n        uint136 weight;\n    }\n\n    constructor(bytes memory _deployData, address _masterDeployer) ERC20(\"Sushi LP Token\", \"SLP\", 18) {\n        (address[] memory _tokens, uint136[] memory _weights, uint256 _swapFee) = abi.decode(_deployData, (address[], uint136[], uint256));\n        // @dev Factory ensures that the tokens are sorted.\n        require(_tokens.length == _weights.length, \"INVALID_ARRAYS\");\n        require(MIN_FEE <= _swapFee && _swapFee <= MAX_FEE, \"INVALID_SWAP_FEE\");\n        require(MIN_TOKENS <= _tokens.length && _tokens.length <= MAX_TOKENS, \"INVALID_TOKENS_LENGTH\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            require(_tokens[i] != address(0), \"ZERO_ADDRESS\");\n            require(MIN_WEIGHT <= _weights[i] && _weights[i] <= MAX_WEIGHT, \"INVALID_WEIGHT\");\n            records[_tokens[i]] = Record({reserve: 0, weight: _weights[i]});\n            tokens.push(_tokens[i]);\n            totalWeight += _weights[i];\n        }\n\n        require(totalWeight <= MAX_TOTAL_WEIGHT, \"MAX_TOTAL_WEIGHT\");\n        // @dev This burns initial LP supply.\n        _mint(address(0), INIT_POOL_SUPPLY);\n\n        swapFee = _swapFee;\n        barFee = IMasterDeployer(_masterDeployer).barFee();\n        barFeeTo = IMasterDeployer(_masterDeployer).barFeeTo();\n        bento = IBentoBoxMinimal(IMasterDeployer(_masterDeployer).bento());\n        masterDeployer = IMasterDeployer(_masterDeployer);\n    }\n\n    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.\n    /// The router must ensure that sufficient LP tokens are minted by using the return value.\n    function mint(bytes calldata data) public override nonReentrant returns (uint256 liquidity) {\n        (address recipient, uint256 toMint) = abi.decode(data, (address, uint256));\n\n        uint120 ratio = uint120(_div(toMint, totalSupply));\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address tokenIn = tokens[i];\n            uint120 reserve = records[tokenIn].reserve;\n            // @dev If token balance is '0', initialize with `ratio`.\n            uint120 amountIn = reserve != 0 ? uint120(_mul(ratio, reserve)) : ratio;\n            require(amountIn >= MIN_BALANCE, \"MIN_BALANCE\");\n            // @dev Check Trident router has sent `amountIn` for skim into pool.\n            unchecked {\n                // @dev This is safe from overflow - only logged amounts handled.\n                require(_balance(tokenIn) >= amountIn + reserve, \"NOT_RECEIVED\");\n                records[tokenIn].reserve += amountIn;\n            }\n            emit Mint(msg.sender, tokenIn, amountIn, recipient);\n        }\n        _mint(recipient, toMint);\n        liquidity = toMint;\n    }\n\n    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.\n    function burn(bytes calldata data) public override nonReentrant returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, bool, uint256));\n\n        uint256 ratio = _div(toBurn, totalSupply);\n\n        withdrawnAmounts = new TokenAmount[](tokens.length);\n\n        _burn(address(this), toBurn);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            address tokenOut = tokens[i];\n            uint256 balance = records[tokenOut].reserve;\n            uint120 amountOut = uint120(_mul(ratio, balance));\n            require(amountOut != 0, \"ZERO_OUT\");\n            // @dev This is safe from underflow - only logged amounts handled.\n            unchecked {\n                records[tokenOut].reserve -= amountOut;\n            }\n            _transfer(tokenOut, amountOut, recipient, unwrapBento);\n            withdrawnAmounts[i] = TokenAmount({token: tokenOut, amount: amountOut});\n            emit Burn(msg.sender, tokenOut, amountOut, recipient);\n        }\n    }\n\n    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another\n    /// - i.e., the user gets a single token out by burning LP tokens.\n    function burnSingle(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento, uint256 toBurn) = abi.decode(data, (address, address, bool, uint256));\n\n        Record storage outRecord = records[tokenOut];\n\n        amountOut = _computeSingleOutGivenPoolIn(outRecord.reserve, outRecord.weight, totalSupply, totalWeight, toBurn, swapFee);\n\n        require(amountOut <= _mul(outRecord.reserve, MAX_OUT_RATIO), \"MAX_OUT_RATIO\");\n        // @dev This is safe from underflow - only logged amounts handled.\n        unchecked {\n            outRecord.reserve -= uint120(amountOut);\n        }\n        _burn(address(this), toBurn);\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        emit Burn(msg.sender, tokenOut, amountOut, recipient);\n    }\n\n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\n    function swap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn) = abi.decode(\n            data,\n            (address, address, address, bool, uint256)\n        );\n\n        Record storage inRecord = records[tokenIn];\n        Record storage outRecord = records[tokenOut];\n\n        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), \"MAX_IN_RATIO\");\n\n        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);\n        // @dev Check Trident router has sent `amountIn` for skim into pool.\n        unchecked {\n            // @dev This is safe from under/overflow - only logged amounts handled.\n            require(_balance(tokenIn) >= amountIn + inRecord.reserve, \"NOT_RECEIVED\");\n            inRecord.reserve += uint120(amountIn);\n            outRecord.reserve -= uint120(amountOut);\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n\n    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.\n    function flashSwap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenIn, address tokenOut, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(\n            data,\n            (address, address, address, bool, uint256, bytes)\n        );\n\n        Record storage inRecord = records[tokenIn];\n        Record storage outRecord = records[tokenOut];\n\n        require(amountIn <= _mul(inRecord.reserve, MAX_IN_RATIO), \"MAX_IN_RATIO\");\n\n        amountOut = _getAmountOut(amountIn, inRecord.reserve, inRecord.weight, outRecord.reserve, outRecord.weight);\n\n        ITridentCallee(msg.sender).tridentSwapCallback(context);\n        // @dev Check Trident router has sent `amountIn` for skim into pool.\n        unchecked {\n            // @dev This is safe from under/overflow - only logged amounts handled.\n            require(_balance(tokenIn) >= amountIn + inRecord.reserve, \"NOT_RECEIVED\");\n            inRecord.reserve += uint120(amountIn);\n            outRecord.reserve -= uint120(amountOut);\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n\n    /// @dev Updates `barFee` for Trident protocol.\n    function updateBarFee() public {\n        barFee = IMasterDeployer(masterDeployer).barFee();\n    }\n\n    function _balance(address token) internal view returns (uint256 balance) {\n        balance = bento.balanceOf(token, address(this));\n    }\n\n    function _getAmountOut(\n        uint256 tokenInAmount,\n        uint256 tokenInBalance,\n        uint256 tokenInWeight,\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight\n    ) internal view returns (uint256 amountOut) {\n        uint256 weightRatio = _div(tokenInWeight, tokenOutWeight);\n        // @dev This is safe from under/overflow - only logged amounts handled.\n        unchecked {\n            uint256 adjustedIn = _mul(tokenInAmount, (BASE - swapFee));\n            uint256 a = _div(tokenInBalance, tokenInBalance + adjustedIn);\n            uint256 b = _compute(a, weightRatio);\n            uint256 c = BASE - b;\n            amountOut = _mul(tokenOutBalance, c);\n        }\n    }\n\n    function _compute(uint256 base, uint256 exp) internal pure returns (uint256 output) {\n        require(MIN_POW_BASE <= base && base <= MAX_POW_BASE, \"INVALID_BASE\");\n\n        uint256 whole = (exp / BASE) * BASE;\n        uint256 remain = exp - whole;\n        uint256 wholePow = _pow(base, whole / BASE);\n\n        if (remain == 0) output = wholePow;\n\n        uint256 partialResult = _powApprox(base, remain, POW_PRECISION);\n        output = _mul(wholePow, partialResult);\n    }\n\n    function _computeSingleOutGivenPoolIn(\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight,\n        uint256 _totalSupply,\n        uint256 _totalWeight,\n        uint256 toBurn,\n        uint256 _swapFee\n    ) internal pure returns (uint256 amountOut) {\n        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);\n        uint256 newPoolSupply = _totalSupply - toBurn;\n        uint256 poolRatio = _div(newPoolSupply, _totalSupply);\n        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));\n        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);\n        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;\n        uint256 zaz = (BASE - normalizedWeight) * _swapFee;\n        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));\n    }\n\n    function _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {\n        output = n % 2 != 0 ? a : BASE;\n        for (n /= 2; n != 0; n /= 2) a = a * a;\n        if (n % 2 != 0) output = output * a;\n    }\n\n    function _powApprox(\n        uint256 base,\n        uint256 exp,\n        uint256 precision\n    ) internal pure returns (uint256 sum) {\n        uint256 a = exp;\n        (uint256 x, bool xneg) = _subFlag(base, BASE);\n        uint256 term = BASE;\n        sum = term;\n        bool negative;\n\n        for (uint256 i = 1; term >= precision; i++) {\n            uint256 bigK = i * BASE;\n            (uint256 c, bool cneg) = _subFlag(a, (bigK - BASE));\n            term = _mul(term, _mul(c, x));\n            term = _div(term, bigK);\n            if (term == 0) break;\n            if (xneg) negative = !negative;\n            if (cneg) negative = !negative;\n            if (negative) {\n                sum = sum - term;\n            } else {\n                sum = sum + term;\n            }\n        }\n    }\n\n    function _subFlag(uint256 a, uint256 b) internal pure returns (uint256 difference, bool flag) {\n        // @dev This is safe from underflow - if/else flow performs checks.\n        unchecked {\n            if (a >= b) {\n                (difference, flag) = (a - b, false);\n            } else {\n                (difference, flag) = (b - a, true);\n            }\n        }\n    }\n\n    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c2) {\n        uint256 c0 = a * b;\n        uint256 c1 = c0 + (BASE / 2);\n        c2 = c1 / BASE;\n    }\n\n    function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {\n        uint256 c0 = a * BASE;\n        uint256 c1 = c0 + (b / 2);\n        c2 = c1 / b;\n    }\n\n    function _transfer(\n        address token,\n        uint256 shares,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, address(this), to, 0, shares);\n        } else {\n            bento.transfer(token, address(this), to, shares);\n        }\n    }\n\n    function getAssets() public view override returns (address[] memory assets) {\n        assets = tokens;\n    }\n\n    function getAmountOut(bytes calldata data) public view override returns (uint256 amountOut) {\n        (uint256 tokenInAmount, uint256 tokenInBalance, uint256 tokenInWeight, uint256 tokenOutBalance, uint256 tokenOutWeight) = abi\n            .decode(data, (uint256, uint256, uint256, uint256, uint256));\n        amountOut = _getAmountOut(tokenInAmount, tokenInBalance, tokenInWeight, tokenOutBalance, tokenOutWeight);\n    }\n\n    function getAmountIn(bytes calldata) public pure override returns (uint256) {\n        revert();\n    }\n\n    function getReservesAndWeights() public view returns (uint256[] memory reserves, uint136[] memory weights) {\n        uint256 length = tokens.length;\n        reserves = new uint256[](length);\n        weights = new uint136[](length);\n        // @dev This is safe from overflow - `tokens` `length` is bound to '8'.\n        unchecked {\n            for (uint256 i = 0; i < length; i++) {\n                reserves[i] = records[tokens[i]].reserve;\n                weights[i] = records[tokens[i]].weight;\n            }\n        }\n    }\n}\n"
    },
    "contracts/pool/index/IndexPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./IndexPool.sol\";\nimport \"../../abstract/PoolDeployer.sol\";\n\n/// @notice Contract for deploying Trident exchange Index Pool with configurations.\n/// @author Mudit Gupta\ncontract IndexPoolFactory is PoolDeployer {\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n\n    function deployPool(bytes memory _deployData) external returns (address pool) {\n        (address[] memory tokens, uint136[] memory weights, uint256 swapFee) = abi.decode(_deployData, (address[], uint136[], uint256));\n\n        // @dev Strips any extra data.\n        _deployData = abi.encode(tokens, weights, swapFee);\n\n        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.\n        bytes32 salt = keccak256(_deployData);\n        pool = address(new IndexPool{salt: salt}(_deployData, masterDeployer));\n        _registerPool(pool, tokens, salt);\n    }\n}\n"
    },
    "contracts/pool/constant-product/ConstantProductPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport {ReentrancyGuard} from \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\";\n\nimport {IBentoBoxMinimal} from \"../../interfaces/IBentoBoxMinimal.sol\";\nimport {IMasterDeployer} from \"../../interfaces/IMasterDeployer.sol\";\nimport {IPool} from \"../../interfaces/IPool.sol\";\nimport {ITridentCallee} from \"../../interfaces/ITridentCallee.sol\";\n\nimport {TridentMath} from \"../../libraries/TridentMath.sol\";\n\n/// @dev Custom Errors\nerror ZeroAddress();\nerror IdenticalAddress();\nerror InvalidSwapFee();\nerror InvalidAmounts();\nerror InsufficientLiquidityMinted();\nerror InvalidOutputToken();\nerror InvalidInputToken();\nerror PoolUninitialized();\nerror InsufficientAmountIn();\nerror Overflow();\n\n/// @notice Trident exchange pool template with constant product formula for swapping between an ERC-20 token pair.\n/// @dev The reserves are stored as bento shares.\n///      The curve is applied to shares as well. This pool does not care about the underlying amounts.\ncontract ConstantProductPool is IPool, ERC20, ReentrancyGuard {\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\n    event Sync(uint256 reserve0, uint256 reserve1);\n\n    uint256 internal constant MINIMUM_LIQUIDITY = 1000;\n\n    uint8 internal constant PRECISION = 112;\n    uint256 internal constant MAX_FEE = 10000; // @dev 100%.\n    uint256 internal constant MAX_FEE_SQUARE = 100000000;\n    uint256 public immutable swapFee;\n    uint256 internal immutable MAX_FEE_MINUS_SWAP_FEE;\n\n    address public immutable barFeeTo;\n    IBentoBoxMinimal public immutable bento;\n    IMasterDeployer public immutable masterDeployer;\n    address public immutable token0;\n    address public immutable token1;\n\n    uint256 public barFee;\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast;\n\n    uint112 internal reserve0;\n    uint112 internal reserve1;\n    uint32 internal blockTimestampLast;\n\n    bytes32 public constant override poolIdentifier = \"Trident:ConstantProduct\";\n\n    constructor(bytes memory _deployData, IMasterDeployer _masterDeployer) ERC20(\"Sushi LP Token\", \"SLP\", 18) {\n        (address _token0, address _token1, uint256 _swapFee, bool _twapSupport) = abi.decode(\n            _deployData,\n            (address, address, uint256, bool)\n        );\n\n        // Factory ensures that the tokens are sorted.\n        if (_token0 == address(0)) revert ZeroAddress();\n        if (_token0 == _token1) revert IdenticalAddress();\n        if (_swapFee > MAX_FEE) revert InvalidSwapFee();\n\n        token0 = _token0;\n        token1 = _token1;\n        swapFee = _swapFee;\n        // This is safe from underflow - `swapFee` cannot exceed `MAX_FEE` per previous check.\n        unchecked {\n            MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;\n        }\n        barFee = _masterDeployer.barFee();\n        barFeeTo = _masterDeployer.barFeeTo();\n        bento = IBentoBoxMinimal(_masterDeployer.bento());\n        masterDeployer = _masterDeployer;\n        if (_twapSupport) blockTimestampLast = uint32(block.timestamp);\n    }\n\n    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.\n    /// The router must ensure that sufficient LP tokens are minted by using the return value.\n    function mint(bytes calldata data) public override nonReentrant returns (uint256 liquidity) {\n        address recipient = abi.decode(data, (address));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n\n        uint256 computed = TridentMath.sqrt(balance0 * balance1);\n        uint256 amount0 = balance0 - _reserve0;\n        uint256 amount1 = balance1 - _reserve1;\n\n        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);\n        _reserve0 += uint112(fee0);\n        _reserve1 += uint112(fee1);\n\n        (uint256 _totalSupply, uint256 k) = _mintFee(_reserve0, _reserve1);\n\n        if (_totalSupply == 0) {\n            if (amount0 == 0 || amount1 == 0) revert InvalidAmounts();\n            liquidity = computed - MINIMUM_LIQUIDITY;\n            _mint(address(0), MINIMUM_LIQUIDITY);\n        } else {\n            uint256 kIncrease;\n            unchecked {\n                kIncrease = computed - k;\n            }\n            liquidity = (kIncrease * _totalSupply) / k;\n        }\n        if (liquidity == 0) revert InsufficientLiquidityMinted();\n        _mint(recipient, liquidity);\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        kLast = computed;\n        emit Mint(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.\n    function burn(bytes calldata data) public override nonReentrant returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 liquidity = balanceOf[address(this)];\n\n        (uint256 _totalSupply, ) = _mintFee(_reserve0, _reserve1);\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        _burn(address(this), liquidity);\n        _transfer(token0, amount0, recipient, unwrapBento);\n        _transfer(token1, amount1, recipient, unwrapBento);\n        // This is safe from underflow - amounts are lesser figures derived from balances.\n        unchecked {\n            balance0 -= amount0;\n            balance1 -= amount1;\n        }\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        kLast = TridentMath.sqrt(balance0 * balance1);\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: address(token0), amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: address(token1), amount: amount1});\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another\n    /// - i.e., the user gets a single token out by burning LP tokens.\n    function burnSingle(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        uint256 liquidity = balanceOf[address(this)];\n\n        (uint256 _totalSupply, ) = _mintFee(_reserve0, _reserve1);\n\n        uint256 amount0 = (liquidity * _reserve0) / _totalSupply;\n        uint256 amount1 = (liquidity * _reserve1) / _totalSupply;\n\n        kLast = TridentMath.sqrt((_reserve0 - amount0) * (_reserve1 - amount1));\n\n        _burn(address(this), liquidity);\n\n        // Swap one token for another\n        unchecked {\n            if (tokenOut == token1) {\n                // Swap `token0` for `token1`\n                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.\n                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);\n                _transfer(token1, amount1, recipient, unwrapBento);\n                amountOut = amount1;\n                amount0 = 0;\n            } else {\n                // Swap `token1` for `token0`.\n                if (tokenOut != token0) revert InvalidOutputToken();\n                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);\n                _transfer(token0, amount0, recipient, unwrapBento);\n                amountOut = amount0;\n                amount1 = 0;\n            }\n        }\n\n        (uint256 balance0, uint256 balance1) = _balance();\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }\n\n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\n    function swap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        if (_reserve0 == 0) revert PoolUninitialized();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 amountIn;\n        address tokenOut;\n        unchecked {\n            if (tokenIn == token0) {\n                tokenOut = token1;\n                amountIn = balance0 - _reserve0;\n                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\n                balance1 -= amountOut;\n            } else {\n                if (tokenIn != token1) revert InvalidInputToken();\n                tokenOut = token0;\n                amountIn = balance1 - reserve1;\n                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\n                balance0 -= amountOut;\n            }\n        }\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\n    }\n\n    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.\n    function flashSwap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\n        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(\n            data,\n            (address, address, bool, uint256, bytes)\n        );\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        if (_reserve0 == 0) revert PoolUninitialized();\n        unchecked {\n            if (tokenIn == token0) {\n                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\n                _transfer(token1, amountOut, recipient, unwrapBento);\n                ITridentCallee(msg.sender).tridentSwapCallback(context);\n                (uint256 balance0, uint256 balance1) = _balance();\n                if (balance0 - _reserve0 < amountIn) revert InsufficientAmountIn();\n                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n                emit Swap(recipient, tokenIn, token1, amountIn, amountOut);\n            } else {\n                if (tokenIn != token1) revert InvalidInputToken();\n                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\n                _transfer(token0, amountOut, recipient, unwrapBento);\n                ITridentCallee(msg.sender).tridentSwapCallback(context);\n                (uint256 balance0, uint256 balance1) = _balance();\n                if (balance1 - _reserve1 < amountIn) revert InsufficientAmountIn();\n                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n                emit Swap(recipient, tokenIn, token0, amountIn, amountOut);\n            }\n        }\n    }\n\n    /// @dev Updates `barFee` for Trident protocol.\n    function updateBarFee() public {\n        barFee = masterDeployer.barFee();\n    }\n\n    function _getReserves()\n        internal\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _balance() internal view returns (uint256 balance0, uint256 balance1) {\n        balance0 = bento.balanceOf(token0, address(this));\n        balance1 = bento.balanceOf(token1, address(this));\n    }\n\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1,\n        uint32 _blockTimestampLast\n    ) internal {\n        if (balance0 > type(uint112).max || balance1 > type(uint112).max) revert Overflow();\n        if (_blockTimestampLast == 0) {\n            // TWAP support is disabled for gas efficiency.\n            reserve0 = uint112(balance0);\n            reserve1 = uint112(balance1);\n        } else {\n            uint32 blockTimestamp = uint32(block.timestamp);\n            if (blockTimestamp != _blockTimestampLast && _reserve0 != 0 && _reserve1 != 0) {\n                unchecked {\n                    uint32 timeElapsed = blockTimestamp - _blockTimestampLast;\n                    uint256 price0 = (uint256(_reserve1) << PRECISION) / _reserve0;\n                    price0CumulativeLast += price0 * timeElapsed;\n                    uint256 price1 = (uint256(_reserve0) << PRECISION) / _reserve1;\n                    price1CumulativeLast += price1 * timeElapsed;\n                }\n            }\n            reserve0 = uint112(balance0);\n            reserve1 = uint112(balance1);\n            blockTimestampLast = blockTimestamp;\n        }\n        emit Sync(balance0, balance1);\n    }\n\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) internal returns (uint256 _totalSupply, uint256 computed) {\n        _totalSupply = totalSupply;\n        uint256 _kLast = kLast;\n        if (_kLast != 0) {\n            computed = TridentMath.sqrt(uint256(_reserve0) * _reserve1);\n            if (computed > _kLast) {\n                // `barFee` % of increase in liquidity.\n                uint256 _barFee = barFee;\n                uint256 numerator = _totalSupply * (computed - _kLast) * _barFee;\n                uint256 denominator = (MAX_FEE - _barFee) * computed + _barFee * _kLast;\n                uint256 liquidity = numerator / denominator;\n\n                if (liquidity != 0) {\n                    _mint(barFeeTo, liquidity);\n                    _totalSupply += liquidity;\n                }\n            }\n        }\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveAmountIn,\n        uint256 reserveAmountOut\n    ) internal view returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * MAX_FEE_MINUS_SWAP_FEE;\n        amountOut = (amountInWithFee * reserveAmountOut) / (reserveAmountIn * MAX_FEE + amountInWithFee);\n    }\n\n    function _getAmountIn(\n        uint256 amountOut,\n        uint256 reserveAmountIn,\n        uint256 reserveAmountOut\n    ) internal view returns (uint256 amountIn) {\n        amountIn = (reserveAmountIn * amountOut * MAX_FEE) / ((reserveAmountOut - amountOut) * MAX_FEE_MINUS_SWAP_FEE) + 1;\n    }\n\n    function _transfer(\n        address token,\n        uint256 shares,\n        address to,\n        bool unwrapBento\n    ) internal {\n        if (unwrapBento) {\n            bento.withdraw(token, address(this), to, 0, shares);\n        } else {\n            bento.transfer(token, address(this), to, shares);\n        }\n    }\n\n    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.\n    function _nonOptimalMintFee(\n        uint256 _amount0,\n        uint256 _amount1,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {\n        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);\n        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;\n        if (amount1Optimal <= _amount1) {\n            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);\n        } else {\n            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;\n            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);\n        }\n    }\n\n    function getAssets() public view override returns (address[] memory assets) {\n        assets = new address[](2);\n        assets[0] = token0;\n        assets[1] = token1;\n    }\n\n    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {\n        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();\n        if (tokenIn == token0) {\n            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\n        } else {\n            if (tokenIn != token1) revert InvalidInputToken();\n            finalAmountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\n        }\n    }\n\n    function getAmountIn(bytes calldata data) public view override returns (uint256 finalAmountIn) {\n        (address tokenOut, uint256 amountOut) = abi.decode(data, (address, uint256));\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();\n        if (tokenOut == token1) {\n            finalAmountIn = _getAmountIn(amountOut, _reserve0, _reserve1);\n        } else {\n            if (tokenOut != token0) revert InvalidOutputToken();\n            finalAmountIn = _getAmountIn(amountOut, _reserve1, _reserve0);\n        }\n    }\n\n    /// @dev Returned values are in terms of BentoBox \"shares\".\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        return _getReserves();\n    }\n\n    /// @dev Returned values are the native ERC20 token amounts.\n    function getNativeReserves()\n        public\n        view\n        returns (\n            uint256 _nativeReserve0,\n            uint256 _nativeReserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        (uint112 _reserve0, uint112 _reserve1, uint32 __blockTimestampLast) = _getReserves();\n        _nativeReserve0 = bento.toAmount(token0, _reserve0, false);\n        _nativeReserve1 = bento.toAmount(token1, _reserve1, false);\n        _blockTimestampLast = __blockTimestampLast;\n    }\n}\n"
    },
    "contracts/pool/constant-product/ConstantProductPoolFactoryHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"./ConstantProductPool.sol\";\nimport \"./ConstantProductPoolFactory.sol\";\n\n/// @notice Helper Contract for fetching info for several pools\n/// @author Ilya Lyalin\ncontract ConstantProductPoolFactoryHelper {\n    struct ConstantProductPoolInfo {\n        uint8 tokenA;\n        uint8 tokenB;\n        uint112 reserve0;\n        uint112 reserve1;\n        uint16 swapFeeAndTwapSupport;\n    }\n\n    // @dev tokens MUST be sorted i < j => token[i] < token[j]\n    // @dev tokens.length < 256\n    function getPoolsForTokens(address constantProductPoolFactory, address[] calldata tokens)\n        external\n        view\n        returns (ConstantProductPoolInfo[] memory poolInfos, uint256 length)\n    {\n        ConstantProductPoolFactory factory = ConstantProductPoolFactory(constantProductPoolFactory);\n        uint8 tokenNumber = uint8(tokens.length);\n        uint256[] memory poolLength = new uint256[]((tokenNumber * (tokenNumber + 1)) / 2);\n        uint256 pairNumber = 0;\n        for (uint8 i = 0; i < tokenNumber; i++) {\n            for (uint8 j = i + 1; j < tokenNumber; j++) {\n                uint256 count = factory.poolsCount(tokens[i], tokens[j]);\n                poolLength[pairNumber++] = count;\n                length += count;\n            }\n        }\n        poolInfos = new ConstantProductPoolInfo[](length);\n        pairNumber = 0;\n        uint256 poolNumber = 0;\n        for (uint8 i = 0; i < tokenNumber; i++) {\n            for (uint8 j = i + 1; j < tokenNumber; j++) {\n                address[] memory pools = factory.getPools(tokens[i], tokens[j], 0, poolLength[pairNumber++]);\n                for (uint256 k = 0; k < pools.length; k++) {\n                    ConstantProductPoolInfo memory poolInfo = poolInfos[poolNumber++];\n                    poolInfo.tokenA = i;\n                    poolInfo.tokenB = j;\n                    ConstantProductPool pool = ConstantProductPool(pools[k]);\n                    (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pool.getReserves();\n                    poolInfo.reserve0 = reserve0;\n                    poolInfo.reserve1 = reserve1;\n                    poolInfo.swapFeeAndTwapSupport = uint16(pool.swapFee());\n                    if (blockTimestampLast != 0) poolInfo.swapFeeAndTwapSupport += 1 << 15;\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/pool/constant-product/ConstantProductPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport {PoolDeployer} from \"../../abstract/PoolDeployer.sol\";\nimport {IMasterDeployer} from \"../../interfaces/IMasterDeployer.sol\";\nimport {ConstantProductPool} from \"./ConstantProductPool.sol\";\n\n/// @notice Contract for deploying Trident exchange Constant Product Pool with configurations.\n/// @author Mudit Gupta.\ncontract ConstantProductPoolFactory is PoolDeployer {\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n\n    function deployPool(bytes memory _deployData) external returns (address pool) {\n        (address tokenA, address tokenB, uint256 swapFee, bool twapSupport) = abi.decode(_deployData, (address, address, uint256, bool));\n\n        if (tokenA > tokenB) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n\n        // Strips any extra data.\n        _deployData = abi.encode(tokenA, tokenB, swapFee, twapSupport);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        // Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.\n        bytes32 salt = keccak256(_deployData);\n        pool = address(new ConstantProductPool{salt: salt}(_deployData, IMasterDeployer(masterDeployer)));\n        _registerPool(pool, tokens, salt);\n    }\n}\n"
    },
    "contracts/mocks/TridentMathMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.2;\n\nimport \"../libraries/TridentMath.sol\";\n\ncontract TridentMathMock {\n    function sqrt(uint256 x) public pure returns (uint256) {\n        return TridentMath.sqrt(x);\n    }\n}\n"
    },
    "contracts/mocks/FlashSwapMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/ITridentCallee.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IBentoBoxMinimal.sol\";\n\n\ncontract FlashSwapMock {\n    IBentoBoxMinimal public immutable bento;\n\n    constructor(IBentoBoxMinimal _bento) {\n        bento = _bento;\n    }\n\n    function testFlashSwap(IPool pair, bytes calldata data) external {\n        pair.flashSwap(data);\n    }\n\n    function tridentSwapCallback(bytes calldata data) external {\n        (bool success, address token, bool viaBento) = abi.decode(data, (bool, address, bool));\n        if (success) {\n            if (viaBento) {\n                uint256 tokenBalanceBento = bento.balanceOf(token, address(this));\n                bento.transfer(token, address(this), msg.sender, tokenBalanceBento);\n            } else {\n                uint256 tokenBalance = IERC20(token).balanceOf(address(this));\n                IERC20(token).transfer(address(bento), tokenBalance);\n                bento.deposit(token, address(bento), msg.sender, tokenBalance, 0);\n            }\n        }\n    }\n}\n"
    },
    "contracts/migration/TridentSushiRollCP.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../abstract/SelfPermit.sol\";\nimport \"../abstract/Multicall.sol\";\nimport \"../interfaces/IUniswapV2Minimal.sol\";\nimport \"../interfaces/IBentoBoxMinimal.sol\";\nimport \"../interfaces/ITridentRouter.sol\";\nimport \"../interfaces/IMasterDeployer.sol\";\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../interfaces/IPool.sol\";\n\n/// @notice Liquidity migrator from UniV2 style pool to Trident Constant product pool.\ncontract TridentSushiRollCP is SelfPermit, Multicall {\n    error MinimumOutput();\n\n    IBentoBoxMinimal internal immutable bentoBox;\n    IPoolFactory internal immutable poolFactory;\n    IMasterDeployer internal immutable masterDeployer;\n\n    constructor(\n        IBentoBoxMinimal _bentoBox,\n        IPoolFactory _poolFactory,\n        IMasterDeployer _masterDeployer\n    ) {\n        bentoBox = _bentoBox;\n        poolFactory = _poolFactory;\n        masterDeployer = _masterDeployer;\n    }\n\n    /** @notice Function to migrate existing Sushiswap or other Uniswap V2 style pools to Trident.\n        @param pair Uniswap V2 style liquidity pool address.\n        @param amount Liquidity amount (Lp token balance) to be migrated.\n        @param swapFee Swap fee of the Trident CP pool we are migrating into.\n        @param twapSupport Whether the Trident CP pool we are migrating into supports twap oracles.\n        @param minToken0Received Slippage protection for removing liquidity from a UniV2 style pool.\n        @param minToken1Received Slippage protection for removing liquidity from a UniV2 style pool.\n        @param minLpReceived Slippage protection for minting liquidity on the Trident CP pool.\n        @dev If the pool with the current conditions doesn't exist it will be deployed. */\n    function migrate(\n        IUniswapV2Minimal pair,\n        uint256 amount,\n        uint256 swapFee,\n        bool twapSupport,\n        uint256 minToken0Received,\n        uint256 minToken1Received,\n        uint256 minLpReceived\n    ) external returns (uint256 liquidity) {\n        address token0 = pair.token0();\n        address token1 = pair.token1();\n\n        bytes memory poolData = abi.encode(token0, token1, swapFee, twapSupport);\n        address tridentPool = poolFactory.configAddress(keccak256(poolData));\n\n        if (tridentPool == address(0)) {\n            tridentPool = masterDeployer.deployPool(address(poolFactory), poolData);\n        }\n\n        pair.transferFrom(msg.sender, address(pair), amount);\n        (uint256 amount0, uint256 amount1) = pair.burn(address(bentoBox));\n\n        if (amount0 < minToken0Received || amount1 < minToken1Received) revert MinimumOutput();\n\n        bentoBox.deposit(token0, address(bentoBox), tridentPool, amount0, 0);\n        bentoBox.deposit(token1, address(bentoBox), tridentPool, amount1, 0);\n\n        liquidity = IPool(tridentPool).mint(abi.encode(msg.sender));\n\n        if (liquidity < minLpReceived) revert MinimumOutput();\n    }\n}\n"
    },
    "contracts/interfaces/IUniswapV2Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Minimal Uniswap V2 LP interface.\ninterface IUniswapV2Minimal is IERC20 {\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n}\n"
    },
    "contracts/mocks/RouterMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../abstract/PoolDeployer.sol\";\nimport \"../TridentRouter.sol\";\n\ncontract RouterMock is TridentRouter {\n    constructor(\n        IBentoBoxMinimal bento,\n        IMasterDeployer masterDeployer,\n        address wETH\n    ) TridentRouter(bento, masterDeployer, wETH) {\n        //\n    }\n}\n"
    },
    "contracts/mocks/PoolFactoryMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >= 0.8.0;\n\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../abstract/PoolDeployer.sol\";\nimport \"./PoolTemplateMock.sol\";\n\ncontract PoolFactoryMock is PoolDeployer {\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n    function deployPool(bytes memory _deployData) external onlyMaster returns (address pool) {\n        (address tokenA, address tokenB) = abi.decode(_deployData, (address, address));\n\n        // @dev correctly sorts tokens to ensure _register in PoolDeployer does not revert\n        if (tokenA > tokenB) {\n            (tokenA, tokenB) = (tokenB, tokenA);\n        }\n\n        // @dev Strips any extra data.\n        _deployData = abi.encode(tokenA, tokenB);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.\n        bytes32 salt = keccak256(_deployData);\n        pool = address(new PoolTemplateMock{salt: salt}(_deployData));\n        _registerPool(pool, tokens, salt);\n    }\n}\n"
    },
    "contracts/mocks/PoolTemplateMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >= 0.8.0;\n\ncontract PoolTemplateMock {\n    address public immutable token0;\n    address public immutable token1;\n    constructor(bytes memory _deployData) {\n        (address _token0, address _token1) = abi.decode(\n            _deployData,\n            (address, address)\n        );\n        token0 = _token0;\n        token1 = _token1;\n    }\n}\n"
    },
    "contracts/mocks/PoolDeployerMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >= 0.8.0;\n\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../abstract/PoolDeployer.sol\";\nimport \"./PoolTemplateMock.sol\";\n\ncontract PoolDeployerMock is PoolDeployer {\n    constructor(address _masterDeployer) PoolDeployer(_masterDeployer) {}\n    function deployPool(bytes memory _deployData) external onlyMaster returns (address pool) {\n        (address tokenA, address tokenB) = abi.decode(_deployData, (address, address));\n\n        /// @dev incorrect because there is no sort tokens, causing PoolDeployer to revert\n        /// we want this for testing\n\n        /// @dev Strips any extra data.\n        _deployData = abi.encode(tokenA, tokenB);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = tokenA;\n        tokens[1] = tokenB;\n\n        // @dev Salt is not actually needed since `_deployData` is part of creationCode and already contains the salt.\n        bytes32 salt = keccak256(_deployData);\n        \n        pool = address(new PoolTemplateMock{salt: salt}(_deployData));\n\n        _registerPool(pool, tokens, salt);\n    }\n}\n"
    },
    "contracts/migration/Migrator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IntermediaryToken.sol\";\nimport \"../interfaces/IMasterDeployer.sol\";\nimport \"../interfaces/IBentoBoxMinimal.sol\";\nimport \"../interfaces/IPoolFactory.sol\";\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/IConstantProductPool.sol\";\nimport \"../interfaces/IUniswapV2Minimal.sol\";\n\n/// @notice Trident pool migrator contract for legacy SushiSwap.\n/** Sushiswap's master chef contracts which distribute rewards to LP token holders have the option to migrate liquidity.\n    We can set this contract as the migrator on the master chef contracts to migrate LP positions from the legacy to the new Trident\n    constant product pools. After the migrator is set anyone can call the migrate() function (once per pool) on the master chef contract.\n    Used by MasterChef / MasterChefV2 / MiniChef. */\ncontract Migrator {\n    event Migrate(address indexed oldPool, address indexed newPool, address indexed intermediaryToken);\n\n    /// @dev Intermediary token to new LP token mapping.\n    /// @dev Used to prevent subsequent calls to masterchef's migrate function with the same PID.\n    mapping(address => address) public migrated;\n\n    IBentoBoxMinimal public immutable bento;\n    IMasterDeployer public immutable masterDeployer;\n    IPoolFactory public immutable constantProductPoolFactory;\n    address public immutable masterChef;\n\n    constructor(\n        IBentoBoxMinimal _bento,\n        IMasterDeployer _masterDeployer,\n        IPoolFactory _constantProductPoolFactory,\n        address _masterChef\n    ) {\n        bento = _bento;\n        masterDeployer = _masterDeployer;\n        constantProductPoolFactory = _constantProductPoolFactory;\n        masterChef = _masterChef;\n    }\n\n    /// @notice Method to migrate MasterChef's liquidity from the legacy SushiSwap AMM to the Trident constant product pool.\n    /// @param oldPool Legacy SushiSwap pool.\n    /// @dev Since MasterChef has a requirement to receive the same amount of \"LP\" tokens back after migration we use an\n    /// intermediary token so we can mint the desired balance. After unstaking users can call redeem() on the intermediary\n    /// token to receive their share of the LP tokens of the new Trident constant product pool.\n    function migrate(IUniswapV2Minimal oldPool) external returns (address) {\n        require(msg.sender == address(masterChef), \"ONLY_CHEF\");\n        require(migrated[address(oldPool)] == address(0), \"ONLY_ONCE\");\n\n        address token0 = oldPool.token0();\n        address token1 = oldPool.token1();\n\n        bytes memory deployData = abi.encode(token0, token1, 30, false);\n\n        IConstantProductPool pool = IConstantProductPool(constantProductPoolFactory.configAddress(keccak256(deployData)));\n\n        // We deploy the pool if it doesn't exist yet.\n        if (address(pool) == address(0)) {\n            pool = IConstantProductPool(masterDeployer.deployPool(address(constantProductPoolFactory), deployData));\n        }\n\n        // We are migrating all of master chef's balance.\n        uint256 lpBalance = oldPool.balanceOf(address(masterChef));\n\n        if (lpBalance == 0) {\n            return address(pool);\n        }\n\n        // Remove the liquidity and send assets to BentoBox.\n        oldPool.transferFrom(address(masterChef), address(oldPool), lpBalance);\n        (uint256 amount0, uint256 amount1) = oldPool.burn(address(bento));\n\n        bento.deposit(token0, address(bento), address(pool), amount0, 0);\n        bento.deposit(token1, address(bento), address(pool), amount1, 0);\n\n        if (pool.totalSupply() != 0) {\n            // We require the pools' prices to differ by no more than 0.5%.\n            (uint256 _nativeReserve0, uint256 _nativeReserve1, ) = pool.getNativeReserves();\n            uint256 oldPoolPrice = (1e18 * amount0) / amount1;\n            uint256 newPoolPrice = (1e18 * _nativeReserve0) / _nativeReserve1;\n            uint256 priceChange = (1e3 * oldPoolPrice) / newPoolPrice;\n            require(priceChange < 1005 && priceChange >= 995, \"PRICE_DIFFERENCE\");\n        }\n\n        // We mint the intermediary token to Master Chef.\n        address intermediaryToken = address(new IntermediaryToken(address(pool), masterChef, lpBalance));\n\n        // The new Trident pool mints liquidity to the intermediary token.\n        pool.mint(abi.encode(intermediaryToken));\n\n        migrated[intermediaryToken] = address(pool);\n\n        emit Migrate(address(oldPool), address(pool), intermediaryToken);\n\n        return intermediaryToken;\n    }\n}\n"
    },
    "contracts/migration/IntermediaryToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@rari-capital/solmate/src/tokens/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Intermediary token users who are staked in MasterChef will receive after migration.\n/// Can be redeemed for the LP token of the new pool.\ncontract IntermediaryToken is ERC20 {\n    /// @dev Liquidity token of the Trident constant product pool.\n    IERC20 public immutable lpToken;\n\n    constructor(\n        address _lpToken,\n        address _recipient,\n        uint256 _amount\n    ) ERC20(\"Sushi LP Token\", \"SLP\", 18) {\n        lpToken = IERC20(_lpToken);\n        _mint(_recipient, _amount);\n    }\n\n    /// @dev Since we might be rewarding the intermediary token for some time we allow users to mint it.\n    function deposit(uint256 amount) public returns (uint256 minted) {\n        uint256 availableLpTokens = lpToken.balanceOf(address(this));\n        if (availableLpTokens != 0) {\n            minted = (totalSupply * amount) / availableLpTokens;\n        } else {\n            minted = amount;\n        }\n        _mint(msg.sender, minted);\n        require(lpToken.transferFrom(msg.sender, address(this), amount), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function redeem(uint256 amount) public returns (uint256 claimed) {\n        uint256 availableLpTokens = lpToken.balanceOf(address(this));\n        claimed = (availableLpTokens * amount) / totalSupply;\n        _burn(msg.sender, amount);\n        require(lpToken.transfer(msg.sender, claimed), \"TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/interfaces/IConstantProductPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IPool.sol\";\n\ninterface IConstantProductPool is IPool, IERC20 {\n    function getNativeReserves()\n        external\n        view\n        returns (\n            uint256 _nativeReserve0,\n            uint256 _nativeReserve1,\n            uint32\n        );\n}\n"
    },
    "contracts/examples/PoolFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >= 0.8.0;\n\nimport \"../interfaces/IPoolFactory.sol\";\n\nimport \"./PoolTemplate.sol\";\n\n/**\n * @author Mudit Gupta\n */\nabstract contract PoolFactory is IPoolFactory {\n    // Consider deploying via an upgradable proxy to allow upgrading pools in the future\n\n    function deployPool(bytes memory _deployData) external override returns (address) {\n        return address(new PoolTemplate(_deployData));\n    }\n}\n"
    },
    "contracts/examples/PoolTemplate.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.2;\n\n/**\n * @author Mudit Gupta\n */\ncontract PoolTemplate {\n    uint256 public immutable configValue;\n    address public immutable anotherConfigValue;\n\n    constructor(bytes memory _data) {\n        (configValue, anotherConfigValue) = abi.decode(_data, (uint256, address));\n    }\n}\n"
    },
    "contracts/mocks/RebasingMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../libraries/RebaseLibrary.sol\";\nimport \"../libraries/SafeCast.sol\";\n\ncontract RebasingMock {\n\n    using SafeCast for uint256;\n    using RebaseLibrary for Rebase;\n\n    Rebase public total;\n\n    function toBase(uint256  elastic) public view returns (uint256 base) {\n        base =  total.toBase(elastic);\n    }\n\n    function toElastic(uint256 base) public view returns (uint256 elastic) {\n        elastic = total.toElastic(base);\n    }\n\n    function set(uint256 elastic, uint256 base) public {\n        total.elastic = elastic.toUint128();\n        total.base = base.toUint128();\n    }\n    function reset() public {\n        total.elastic = 0;\n        total.base = 0;\n    }\n}\n"
    },
    "contracts/mocks/TransferMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >= 0.8.0;\n\nimport \"../libraries/Transfer.sol\";\n\ncontract TransferMock {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) external {\n        Transfer.safeApprove(token, to, value);\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) external {\n        Transfer.safeTransfer(token, to, value);\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) external {\n        Transfer.safeTransferFrom(token, from, to, value);\n    }\n\n    function safeTransferETH(address to, uint256 value) external {\n        Transfer.safeTransferETH(to, value);\n    }\n}"
    },
    "contracts/pool/concentrated/ConcentratedLiquidityPoolHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../../interfaces/IConcentratedLiquidityPool.sol\";\nimport \"../../libraries/TickMath.sol\";\nimport \"../../libraries/Ticks.sol\";\n\n/// @notice Trident Concentrated Liquidity Pool periphery contract to read state.\ncontract ConcentratedLiquidityPoolHelper {\n    struct SimpleTick {\n        int24 index;\n        uint128 liquidity;\n    }\n\n    function getTickState(IConcentratedLiquidityPool pool, uint24 tickCount) external view returns (SimpleTick[] memory) {\n        SimpleTick[] memory ticks = new SimpleTick[](tickCount); // todo save tickCount in the core contract\n\n        IConcentratedLiquidityPool.Tick memory tick;\n        uint24 i;\n        int24 current = TickMath.MIN_TICK;\n\n        while (current != TickMath.MAX_TICK) {\n            tick = pool.ticks(current);\n            ticks[i++] = SimpleTick({index: current, liquidity: tick.liquidity});\n            current = tick.nextTick;\n        }\n\n        tick = pool.ticks(current);\n        ticks[i] = SimpleTick({index: TickMath.MAX_TICK, liquidity: tick.liquidity});\n\n        return ticks;\n    }\n}\n"
    },
    "contracts/mocks/TickMathMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../libraries/TickMath.sol\";\n\ncontract TickMathMock {\n    function getSqrtRatioAtTick(int24 tick) external pure returns (uint160) {\n        return TickMath.getSqrtRatioAtTick(tick);\n    }\n\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) external pure returns (int24) {\n        return TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n    }\n}\n"
    },
    "contracts/mocks/MulticallMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.8.0;\n\nimport \"../abstract/Multicall.sol\";\n\ncontract MulticallMock is Multicall {\n    function functionThatRevertsWithError(string memory error) external pure {\n        revert(error);\n    }\n\n    function functionThatRevertsWithoutError() external pure {\n        revert();\n    }\n\n    struct Tuple {\n        uint256 a;\n        uint256 b;\n    }\n\n    function functionThatReturnsTuple(uint256 a, uint256 b) external pure returns (Tuple memory tuple) {\n        tuple = Tuple({b: a, a: b});\n    }\n\n    uint256 public paid;\n\n    function pays() external payable {\n        paid += msg.value;\n    }\n\n    function returnSender() external view returns (address) {\n        return msg.sender;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}